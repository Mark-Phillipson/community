# Talon captures and spoken forms

This file was generated by tools/extract_talon_captures.py. It lists captures found in Python files and attempts to show the spoken forms for referenced lists when the lists are defined as literals or via simple helpers.

## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\deprecations.py

- decorator inner: `rule="..."`

- name: `<no explicit name>`

- raw rule: `...`



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\system_paths.py

- decorator inner: `rule="{user.system_paths}"`

- name: `<no explicit name>`

- raw rule: `{user.system_paths}`

- referenced lists:

  - `user.system_paths`: 
<unknown; not a literal in code>



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\tags\debugger\debugger.py

- decorator inner: `rule="{self.registers}"`

- name: `<no explicit name>`

- raw rule: `{self.registers}`

- referenced lists:

  - `self.registers`: 
x64_registers

# assembly_languages = {
#    "x86": x86_registers,
#    "x64": x64_registers,
# }

mod.list("registers", desc="Main architecture register set")


@mod.capture(rule="{self.registers}")
def registers(m) -> str:
    "Returns a register"
    return m.registers


@mod.action_class
class Actions:
    def debugger_step_into():
        """Step into an instruction in the debugger"""

    def debugger_step_over():
        """Step over an instruction in the debugger"""

    def debugger_step_line():
        """Step into a source line in the debugger"""

    def debugger_step_over_line():
        """Step over a source line in the debugger"""

    def debugger_step_out():
        """Step until function exit in the debugger"""

    def debugger_continue():
        """Continue execution in the debugger"""

    def debugger_restart():
        """Restart execution in the debugger"""

    def debugger_start():
        """Start debugging"""

    def debugger_stop():
        """Stop the debugger"""

    def debugger_exit():
        """Exit the debugger"""

    def debugger_detach():
        """Detach the debugger"""

    def debugger_backtrace():
        """Print a back trace in the debugger"""

    def debugger_get_register():
        """Print specific register in the debugger"""

    def debugger_set_register():
        """Set specific register in the debugger"""

    def debugger_show_registers():
        """Print the current registers in the debugger"""

    def debugger_break_now():
        """Break into the debugger"""

    def debugger_break_here():
        """Set a break on the current line"""

    def debugger_show_breakpoints():
        """Print the current breakpoints in the debugger"""

    def debugger_add_sw_breakpoint():
        """Add one software breakpoint in the debugger"""

    def debugger_add_hw_breakpoint():
        """Add one hardware breakpoint in the debugger"""

    def debugger_clear_all_breakpoints():
        """Clear all breakpoints in the debugger"""

    def debugger_clear_breakpoint():
        """Clear one breakpoint in the debugger"""

    def debugger_clear_breakpoint_id(number_small: int):
        """Clear one breakpoint id in the debugger"""

    def debugger_disable_breakpoint_id(number_small: int):
        """Disable one breakpoint id in the debugger"""

    def debugger_disable_breakpoint():
        """Disable one breakpoint in the debugger"""

    def debugger_disable_all_breakpoints():
        """Disable all breakpoints in the debugger"""

    def debugger_enable_breakpoint():
        """Enable one breakpoint in the debugger"""

    def debugger_enable_breakpoint_id(number_small: int):
        """Enable one breakpoint id in the debugger"""

    def debugger_enable_all_breakpoints():
        """Enable all breakpoints in the debugger"""

    def debugger_disassemble():
        """Preps the disassemble command in the debugger"""

    def debugger_disassemble_here():
        """Disassembles instructions at the current instruction pointer"""

    def debugger_disassemble_clipboard():
        """Disassemble instructions at an address in the clipboard"""

    def debugger_goto_address():
        """Jump to a specific address in the debugger"""

    def debugger_goto_clipboard():
        """Jump to a specific address stored in the clipboard"""

    def debugger_goto_highlighted():
        """Jump to a specific highlighted address in the debugger"""

    def debugger_dump_ascii_string():
        """Display as specific address as an ascii string in the debugger"""

    def debugger_dump_unicode_string():
        """Display as specific address as an unicode string in the debugger"""

    def debugger_dump_pointers():
        """Display as specific address as a list of pointers in the debugger"""

    def debugger_inspect_type():
        """Inspect a specific data type in the debugger"""

    def debugger_clear_line():
        """Clear unwanted data from the command line"""

    def debugger_list_modules():
        """List the loaded modules in the debuggee memory space"""



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\plugin\talon_draft_window\draft_talon_helpers.py

- decorator inner: `rule="{self.letter}+"`

- name: `<no explicit name>`

- raw rule: `{self.letter}+`

- referenced lists:

  - `self.letter`: 
<unknown; not a literal in code>



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\plugin\talon_draft_window\draft_talon_helpers.py

- decorator inner: `rule="(top|bottom|left|right|middle`

- name: `<no explicit name>`

- raw rule: `None`

- Resolved: none



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\plugin\text_navigation\text_navigation.py

- decorator inner: `rule="<user.any_alphanumeric_key> | {user.navigation_target_name} | phrase <user.text>"`

- name: `<no explicit name>`

- raw rule: `<user.any_alphanumeric_key> | {user.navigation_target_name} | phrase <user.text>`

- referenced lists:

  - `user.navigation_target_name`: 
<unknown; not a literal in code>

  - `user.any_alphanumeric_key`: 
<unknown; may be defined elsewhere>

  - `user.text`: 
<unknown; may be defined elsewhere>



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\lang\c\c.py

- decorator inner: `rule="{self.c_pointers}"`

- name: `<no explicit name>`

- raw rule: `{self.c_pointers}`

- referenced lists:

  - `self.c_pointers`: 
{
    "pointer": "*",
    "pointer to pointer": "**",
}

c_and_cpp_ctx.lists["self.stdint_signed"] = {
    "signed": "",
    "unsigned": "u",
    "you": "u",
}

c_and_cpp_ctx.lists["self.c_signed"] = {
    "signed": "signed",
    "unsigned": "unsigned",
}

c_and_cpp_ctx.lists["self.stdint_types"] = {
    "character": "int8_t",
    "char": "int8_t",
    "short": "int16_t",
    "long": "int32_t",
    "long long": "int64_t",
    "int": "int32_t",
    "integer": "int32_t",
    "void": "void",
    "double": "double",
    "struct": "struct",
    "struck": "struct",
    "num": "enum",
    "union": "union",
    "float": "float",
}

c_and_cpp_ctx.lists["self.c_types"] = {
    "character": "char",
    "char": "char",
    "short": "short",
    "long": "long",
    "int": "int",
    "integer": "int",
    "void": "void",
    "double": "double",
    "struct": "struct",
    "struck": "struct",
    "num": "enum",
    "union": "union",
    "float": "float",
}

ctx.lists["user.code_libraries"] = {
    "assert": "assert.h",
    "type": "ctype.h",
    "error": "errno.h",
    "float": "float.h",
    "limits": "limits.h",
    "locale": "locale.h",
    "math": "math.h",
    "set jump": "setjmp.h",
    "signal": "signal.h",
    "arguments": "stdarg.h",
    "definition": "stddef.h",
    "input": "stdio.h",
    "output": "stdio.h",
    "library": "stdlib.h",
    "string": "string.h",
    "time": "time.h",
    "standard int": "stdint.h",
}

mod.list("c_pointers", desc="Common C pointers")
mod.list("c_signed", desc="Common C datatype signed modifiers")
mod.list("c_types", desc="Common C types")
mod.list("stdint_types", desc="Common stdint C types")
mod.list("stdint_signed", desc="Common stdint C datatype signed modifiers")


@mod.capture(rule="{self.c_pointers}")
def c_pointers(m) -> str:
    "Returns a string"
    return m.c_pointers


@mod.capture(rule="{self.c_signed}")
def c_signed(m) -> str:
    "Returns a string"
    return m.c_signed


@mod.capture(rule="{self.c_types}")
def c_types(m) -> str:
    "Returns a string"
    return m.c_types


@mod.capture(rule="{self.stdint_types}")
def stdint_types(m) -> str:
    "Returns a string"
    return m.stdint_types


@mod.capture(rule="{self.stdint_signed}")
def stdint_signed(m) -> str:
    "Returns a string"
    return m.stdint_signed


@mod.capture(rule="[<self.c_signed>] <self.c_types> [<self.c_pointers>+]")
def c_cast(m) -> str:
    "Returns a string"
    return "(" + " ".join(list(m)) + ")"


@mod.capture(rule="[<self.stdint_signed>] <self.stdint_types> [<self.c_pointers>+]")
def stdint_cast(m) -> str:
    "Returns a string"
    return "(" + "".join(list(m)) + ")"


@mod.capture(rule="[<self.c_signed>] <self.c_types> [<self.c_pointers>]")
def c_variable(m) -> str:
    "Returns a string"
    return " ".join(list(m))


operators = Operators(
    SUBSCRIPT=create_described_insert_between("[", "]"),
    ASSIGNMENT=" = ",
    ASSIGNMENT_ADDITION=" += ",
    ASSIGNMENT_SUBTRACTION=" -= ",
    ASSIGNMENT_MULTIPLICATION=" *= ",
    ASSIGNMENT_DIVISION=" /= ",
    ASSIGNMENT_MODULO=" %= ",
    ASSIGNMENT_INCREMENT="++",
    ASSIGNMENT_BITWISE_AND=" &= ",
    ASSIGNMENT_BITWISE_OR=" |= ",
    ASSIGNMENT_BITWISE_EXCLUSIVE_OR=" ^= ",
    ASSIGNMENT_BITWISE_LEFT_SHIFT=" <<= ",
    ASSIGNMENT_BITWISE_RIGHT_SHIFT=" >>= ",
    BITWISE_AND=" & ",
    BITWISE_OR=" | ",
    BITWISE_NOT="~",
    BITWISE_EXCLUSIVE_OR=" ^ ",
    BITWISE_LEFT_SHIFT=" << ",
    BITWISE_RIGHT_SHIFT=" >> ",
    MATH_SUBTRACT=" - ",
    MATH_ADD=" + ",
    MATH_MULTIPLY=" * ",
    MATH_DIVIDE=" / ",
    MATH_MODULO=" % ",
    MATH_EQUAL=" == ",
    MATH_NOT_EQUAL=" != ",
    MATH_GREATER_THAN=" > ",
    MATH_GREATER_THAN_OR_EQUAL=" >= ",
    MATH_LESS_THAN=" < ",
    MATH_LESS_THAN_OR_EQUAL=" <= ",
    MATH_AND=" && ",
    MATH_OR=" || ",
    MATH_NOT="!",
    POINTER_INDIRECTION="*",
    POINTER_ADDRESS_OF="&",
    POINTER_STRUCTURE_DEREFERENCE="->",
)


@ctx.action_class("user")
class UserActions:
    def code_get_operators() -> Operators:
        return operators

    def code_insert_null():
        actions.auto_insert("NULL")

    def code_insert_is_null():
        actions.auto_insert(" == NULL ")

    def code_insert_is_not_null():
        actions.auto_insert(" != NULL")

    def code_insert_true():
        actions.auto_insert("true")

    def code_insert_false():
        actions.auto_insert("false")

    def code_insert_function(text: str, selection: str):
        if selection:
            text = text + f"({selection})"
        else:
            text = text + "()"

        actions.user.paste(text)
        actions.edit.left()

    # TODO - it would be nice that you integrate that types from c_cast
    # instead of defaulting to void
    def code_private_function(text: str):
        """Inserts private function declaration"""
        result = "void {}".format(
            actions.user.formatted_text(
                text, settings.get("user.code_private_function_formatter")
            )
        )

        actions.user.code_insert_function(result, None)

    def code_private_static_function(text: str):
        """Inserts private static function"""
        result = "static void {}".format(
            actions.user.formatted_text(
                text, settings.get("user.code_private_function_formatter")
            )
        )

        actions.user.code_insert_function(result, None)

    def code_insert_library(text: str, selection: str):
        actions.user.paste(f"#include <{text}>")



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\lang\c\c.py

- decorator inner: `rule="{self.c_signed}"`

- name: `<no explicit name>`

- raw rule: `{self.c_signed}`

- referenced lists:

  - `self.c_signed`: 
<unknown; not a literal in code>



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\lang\c\c.py

- decorator inner: `rule="{self.c_types}"`

- name: `<no explicit name>`

- raw rule: `{self.c_types}`

- referenced lists:

  - `self.c_types`: 
<unknown; not a literal in code>



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\lang\c\c.py

- decorator inner: `rule="{self.stdint_types}"`

- name: `<no explicit name>`

- raw rule: `{self.stdint_types}`

- referenced lists:

  - `self.stdint_types`: 
<unknown; not a literal in code>



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\lang\c\c.py

- decorator inner: `rule="{self.stdint_signed}"`

- name: `<no explicit name>`

- raw rule: `{self.stdint_signed}`

- referenced lists:

  - `self.stdint_signed`: 
<unknown; not a literal in code>



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\lang\c\c.py

- decorator inner: `rule="[<self.c_signed>] <self.c_types> [<self.c_pointers>+]"`

- name: `<no explicit name>`

- raw rule: `[<self.c_signed>] <self.c_types> [<self.c_pointers>+]`

- referenced lists:

  - `self.c_signed`: 
<unknown; may be defined elsewhere>

  - `self.c_types`: 
<unknown; may be defined elsewhere>

  - `self.c_pointers`: 
{
    "pointer": "*",
    "pointer to pointer": "**",
}

c_and_cpp_ctx.lists["self.stdint_signed"] = {
    "signed": "",
    "unsigned": "u",
    "you": "u",
}

c_and_cpp_ctx.lists["self.c_signed"] = {
    "signed": "signed",
    "unsigned": "unsigned",
}

c_and_cpp_ctx.lists["self.stdint_types"] = {
    "character": "int8_t",
    "char": "int8_t",
    "short": "int16_t",
    "long": "int32_t",
    "long long": "int64_t",
    "int": "int32_t",
    "integer": "int32_t",
    "void": "void",
    "double": "double",
    "struct": "struct",
    "struck": "struct",
    "num": "enum",
    "union": "union",
    "float": "float",
}

c_and_cpp_ctx.lists["self.c_types"] = {
    "character": "char",
    "char": "char",
    "short": "short",
    "long": "long",
    "int": "int",
    "integer": "int",
    "void": "void",
    "double": "double",
    "struct": "struct",
    "struck": "struct",
    "num": "enum",
    "union": "union",
    "float": "float",
}

ctx.lists["user.code_libraries"] = {
    "assert": "assert.h",
    "type": "ctype.h",
    "error": "errno.h",
    "float": "float.h",
    "limits": "limits.h",
    "locale": "locale.h",
    "math": "math.h",
    "set jump": "setjmp.h",
    "signal": "signal.h",
    "arguments": "stdarg.h",
    "definition": "stddef.h",
    "input": "stdio.h",
    "output": "stdio.h",
    "library": "stdlib.h",
    "string": "string.h",
    "time": "time.h",
    "standard int": "stdint.h",
}

mod.list("c_pointers", desc="Common C pointers")
mod.list("c_signed", desc="Common C datatype signed modifiers")
mod.list("c_types", desc="Common C types")
mod.list("stdint_types", desc="Common stdint C types")
mod.list("stdint_signed", desc="Common stdint C datatype signed modifiers")


@mod.capture(rule="{self.c_pointers}")
def c_pointers(m) -> str:
    "Returns a string"
    return m.c_pointers


@mod.capture(rule="{self.c_signed}")
def c_signed(m) -> str:
    "Returns a string"
    return m.c_signed


@mod.capture(rule="{self.c_types}")
def c_types(m) -> str:
    "Returns a string"
    return m.c_types


@mod.capture(rule="{self.stdint_types}")
def stdint_types(m) -> str:
    "Returns a string"
    return m.stdint_types


@mod.capture(rule="{self.stdint_signed}")
def stdint_signed(m) -> str:
    "Returns a string"
    return m.stdint_signed


@mod.capture(rule="[<self.c_signed>] <self.c_types> [<self.c_pointers>+]")
def c_cast(m) -> str:
    "Returns a string"
    return "(" + " ".join(list(m)) + ")"


@mod.capture(rule="[<self.stdint_signed>] <self.stdint_types> [<self.c_pointers>+]")
def stdint_cast(m) -> str:
    "Returns a string"
    return "(" + "".join(list(m)) + ")"


@mod.capture(rule="[<self.c_signed>] <self.c_types> [<self.c_pointers>]")
def c_variable(m) -> str:
    "Returns a string"
    return " ".join(list(m))


operators = Operators(
    SUBSCRIPT=create_described_insert_between("[", "]"),
    ASSIGNMENT=" = ",
    ASSIGNMENT_ADDITION=" += ",
    ASSIGNMENT_SUBTRACTION=" -= ",
    ASSIGNMENT_MULTIPLICATION=" *= ",
    ASSIGNMENT_DIVISION=" /= ",
    ASSIGNMENT_MODULO=" %= ",
    ASSIGNMENT_INCREMENT="++",
    ASSIGNMENT_BITWISE_AND=" &= ",
    ASSIGNMENT_BITWISE_OR=" |= ",
    ASSIGNMENT_BITWISE_EXCLUSIVE_OR=" ^= ",
    ASSIGNMENT_BITWISE_LEFT_SHIFT=" <<= ",
    ASSIGNMENT_BITWISE_RIGHT_SHIFT=" >>= ",
    BITWISE_AND=" & ",
    BITWISE_OR=" | ",
    BITWISE_NOT="~",
    BITWISE_EXCLUSIVE_OR=" ^ ",
    BITWISE_LEFT_SHIFT=" << ",
    BITWISE_RIGHT_SHIFT=" >> ",
    MATH_SUBTRACT=" - ",
    MATH_ADD=" + ",
    MATH_MULTIPLY=" * ",
    MATH_DIVIDE=" / ",
    MATH_MODULO=" % ",
    MATH_EQUAL=" == ",
    MATH_NOT_EQUAL=" != ",
    MATH_GREATER_THAN=" > ",
    MATH_GREATER_THAN_OR_EQUAL=" >= ",
    MATH_LESS_THAN=" < ",
    MATH_LESS_THAN_OR_EQUAL=" <= ",
    MATH_AND=" && ",
    MATH_OR=" || ",
    MATH_NOT="!",
    POINTER_INDIRECTION="*",
    POINTER_ADDRESS_OF="&",
    POINTER_STRUCTURE_DEREFERENCE="->",
)


@ctx.action_class("user")
class UserActions:
    def code_get_operators() -> Operators:
        return operators

    def code_insert_null():
        actions.auto_insert("NULL")

    def code_insert_is_null():
        actions.auto_insert(" == NULL ")

    def code_insert_is_not_null():
        actions.auto_insert(" != NULL")

    def code_insert_true():
        actions.auto_insert("true")

    def code_insert_false():
        actions.auto_insert("false")

    def code_insert_function(text: str, selection: str):
        if selection:
            text = text + f"({selection})"
        else:
            text = text + "()"

        actions.user.paste(text)
        actions.edit.left()

    # TODO - it would be nice that you integrate that types from c_cast
    # instead of defaulting to void
    def code_private_function(text: str):
        """Inserts private function declaration"""
        result = "void {}".format(
            actions.user.formatted_text(
                text, settings.get("user.code_private_function_formatter")
            )
        )

        actions.user.code_insert_function(result, None)

    def code_private_static_function(text: str):
        """Inserts private static function"""
        result = "static void {}".format(
            actions.user.formatted_text(
                text, settings.get("user.code_private_function_formatter")
            )
        )

        actions.user.code_insert_function(result, None)

    def code_insert_library(text: str, selection: str):
        actions.user.paste(f"#include <{text}>")



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\lang\c\c.py

- decorator inner: `rule="[<self.stdint_signed>] <self.stdint_types> [<self.c_pointers>+]"`

- name: `<no explicit name>`

- raw rule: `[<self.stdint_signed>] <self.stdint_types> [<self.c_pointers>+]`

- referenced lists:

  - `self.stdint_signed`: 
<unknown; may be defined elsewhere>

  - `self.stdint_types`: 
<unknown; may be defined elsewhere>

  - `self.c_pointers`: 
{
    "pointer": "*",
    "pointer to pointer": "**",
}

c_and_cpp_ctx.lists["self.stdint_signed"] = {
    "signed": "",
    "unsigned": "u",
    "you": "u",
}

c_and_cpp_ctx.lists["self.c_signed"] = {
    "signed": "signed",
    "unsigned": "unsigned",
}

c_and_cpp_ctx.lists["self.stdint_types"] = {
    "character": "int8_t",
    "char": "int8_t",
    "short": "int16_t",
    "long": "int32_t",
    "long long": "int64_t",
    "int": "int32_t",
    "integer": "int32_t",
    "void": "void",
    "double": "double",
    "struct": "struct",
    "struck": "struct",
    "num": "enum",
    "union": "union",
    "float": "float",
}

c_and_cpp_ctx.lists["self.c_types"] = {
    "character": "char",
    "char": "char",
    "short": "short",
    "long": "long",
    "int": "int",
    "integer": "int",
    "void": "void",
    "double": "double",
    "struct": "struct",
    "struck": "struct",
    "num": "enum",
    "union": "union",
    "float": "float",
}

ctx.lists["user.code_libraries"] = {
    "assert": "assert.h",
    "type": "ctype.h",
    "error": "errno.h",
    "float": "float.h",
    "limits": "limits.h",
    "locale": "locale.h",
    "math": "math.h",
    "set jump": "setjmp.h",
    "signal": "signal.h",
    "arguments": "stdarg.h",
    "definition": "stddef.h",
    "input": "stdio.h",
    "output": "stdio.h",
    "library": "stdlib.h",
    "string": "string.h",
    "time": "time.h",
    "standard int": "stdint.h",
}

mod.list("c_pointers", desc="Common C pointers")
mod.list("c_signed", desc="Common C datatype signed modifiers")
mod.list("c_types", desc="Common C types")
mod.list("stdint_types", desc="Common stdint C types")
mod.list("stdint_signed", desc="Common stdint C datatype signed modifiers")


@mod.capture(rule="{self.c_pointers}")
def c_pointers(m) -> str:
    "Returns a string"
    return m.c_pointers


@mod.capture(rule="{self.c_signed}")
def c_signed(m) -> str:
    "Returns a string"
    return m.c_signed


@mod.capture(rule="{self.c_types}")
def c_types(m) -> str:
    "Returns a string"
    return m.c_types


@mod.capture(rule="{self.stdint_types}")
def stdint_types(m) -> str:
    "Returns a string"
    return m.stdint_types


@mod.capture(rule="{self.stdint_signed}")
def stdint_signed(m) -> str:
    "Returns a string"
    return m.stdint_signed


@mod.capture(rule="[<self.c_signed>] <self.c_types> [<self.c_pointers>+]")
def c_cast(m) -> str:
    "Returns a string"
    return "(" + " ".join(list(m)) + ")"


@mod.capture(rule="[<self.stdint_signed>] <self.stdint_types> [<self.c_pointers>+]")
def stdint_cast(m) -> str:
    "Returns a string"
    return "(" + "".join(list(m)) + ")"


@mod.capture(rule="[<self.c_signed>] <self.c_types> [<self.c_pointers>]")
def c_variable(m) -> str:
    "Returns a string"
    return " ".join(list(m))


operators = Operators(
    SUBSCRIPT=create_described_insert_between("[", "]"),
    ASSIGNMENT=" = ",
    ASSIGNMENT_ADDITION=" += ",
    ASSIGNMENT_SUBTRACTION=" -= ",
    ASSIGNMENT_MULTIPLICATION=" *= ",
    ASSIGNMENT_DIVISION=" /= ",
    ASSIGNMENT_MODULO=" %= ",
    ASSIGNMENT_INCREMENT="++",
    ASSIGNMENT_BITWISE_AND=" &= ",
    ASSIGNMENT_BITWISE_OR=" |= ",
    ASSIGNMENT_BITWISE_EXCLUSIVE_OR=" ^= ",
    ASSIGNMENT_BITWISE_LEFT_SHIFT=" <<= ",
    ASSIGNMENT_BITWISE_RIGHT_SHIFT=" >>= ",
    BITWISE_AND=" & ",
    BITWISE_OR=" | ",
    BITWISE_NOT="~",
    BITWISE_EXCLUSIVE_OR=" ^ ",
    BITWISE_LEFT_SHIFT=" << ",
    BITWISE_RIGHT_SHIFT=" >> ",
    MATH_SUBTRACT=" - ",
    MATH_ADD=" + ",
    MATH_MULTIPLY=" * ",
    MATH_DIVIDE=" / ",
    MATH_MODULO=" % ",
    MATH_EQUAL=" == ",
    MATH_NOT_EQUAL=" != ",
    MATH_GREATER_THAN=" > ",
    MATH_GREATER_THAN_OR_EQUAL=" >= ",
    MATH_LESS_THAN=" < ",
    MATH_LESS_THAN_OR_EQUAL=" <= ",
    MATH_AND=" && ",
    MATH_OR=" || ",
    MATH_NOT="!",
    POINTER_INDIRECTION="*",
    POINTER_ADDRESS_OF="&",
    POINTER_STRUCTURE_DEREFERENCE="->",
)


@ctx.action_class("user")
class UserActions:
    def code_get_operators() -> Operators:
        return operators

    def code_insert_null():
        actions.auto_insert("NULL")

    def code_insert_is_null():
        actions.auto_insert(" == NULL ")

    def code_insert_is_not_null():
        actions.auto_insert(" != NULL")

    def code_insert_true():
        actions.auto_insert("true")

    def code_insert_false():
        actions.auto_insert("false")

    def code_insert_function(text: str, selection: str):
        if selection:
            text = text + f"({selection})"
        else:
            text = text + "()"

        actions.user.paste(text)
        actions.edit.left()

    # TODO - it would be nice that you integrate that types from c_cast
    # instead of defaulting to void
    def code_private_function(text: str):
        """Inserts private function declaration"""
        result = "void {}".format(
            actions.user.formatted_text(
                text, settings.get("user.code_private_function_formatter")
            )
        )

        actions.user.code_insert_function(result, None)

    def code_private_static_function(text: str):
        """Inserts private static function"""
        result = "static void {}".format(
            actions.user.formatted_text(
                text, settings.get("user.code_private_function_formatter")
            )
        )

        actions.user.code_insert_function(result, None)

    def code_insert_library(text: str, selection: str):
        actions.user.paste(f"#include <{text}>")



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\lang\c\c.py

- decorator inner: `rule="[<self.c_signed>] <self.c_types> [<self.c_pointers>]"`

- name: `<no explicit name>`

- raw rule: `[<self.c_signed>] <self.c_types> [<self.c_pointers>]`

- referenced lists:

  - `self.c_signed`: 
<unknown; may be defined elsewhere>

  - `self.c_types`: 
<unknown; may be defined elsewhere>

  - `self.c_pointers`: 
{
    "pointer": "*",
    "pointer to pointer": "**",
}

c_and_cpp_ctx.lists["self.stdint_signed"] = {
    "signed": "",
    "unsigned": "u",
    "you": "u",
}

c_and_cpp_ctx.lists["self.c_signed"] = {
    "signed": "signed",
    "unsigned": "unsigned",
}

c_and_cpp_ctx.lists["self.stdint_types"] = {
    "character": "int8_t",
    "char": "int8_t",
    "short": "int16_t",
    "long": "int32_t",
    "long long": "int64_t",
    "int": "int32_t",
    "integer": "int32_t",
    "void": "void",
    "double": "double",
    "struct": "struct",
    "struck": "struct",
    "num": "enum",
    "union": "union",
    "float": "float",
}

c_and_cpp_ctx.lists["self.c_types"] = {
    "character": "char",
    "char": "char",
    "short": "short",
    "long": "long",
    "int": "int",
    "integer": "int",
    "void": "void",
    "double": "double",
    "struct": "struct",
    "struck": "struct",
    "num": "enum",
    "union": "union",
    "float": "float",
}

ctx.lists["user.code_libraries"] = {
    "assert": "assert.h",
    "type": "ctype.h",
    "error": "errno.h",
    "float": "float.h",
    "limits": "limits.h",
    "locale": "locale.h",
    "math": "math.h",
    "set jump": "setjmp.h",
    "signal": "signal.h",
    "arguments": "stdarg.h",
    "definition": "stddef.h",
    "input": "stdio.h",
    "output": "stdio.h",
    "library": "stdlib.h",
    "string": "string.h",
    "time": "time.h",
    "standard int": "stdint.h",
}

mod.list("c_pointers", desc="Common C pointers")
mod.list("c_signed", desc="Common C datatype signed modifiers")
mod.list("c_types", desc="Common C types")
mod.list("stdint_types", desc="Common stdint C types")
mod.list("stdint_signed", desc="Common stdint C datatype signed modifiers")


@mod.capture(rule="{self.c_pointers}")
def c_pointers(m) -> str:
    "Returns a string"
    return m.c_pointers


@mod.capture(rule="{self.c_signed}")
def c_signed(m) -> str:
    "Returns a string"
    return m.c_signed


@mod.capture(rule="{self.c_types}")
def c_types(m) -> str:
    "Returns a string"
    return m.c_types


@mod.capture(rule="{self.stdint_types}")
def stdint_types(m) -> str:
    "Returns a string"
    return m.stdint_types


@mod.capture(rule="{self.stdint_signed}")
def stdint_signed(m) -> str:
    "Returns a string"
    return m.stdint_signed


@mod.capture(rule="[<self.c_signed>] <self.c_types> [<self.c_pointers>+]")
def c_cast(m) -> str:
    "Returns a string"
    return "(" + " ".join(list(m)) + ")"


@mod.capture(rule="[<self.stdint_signed>] <self.stdint_types> [<self.c_pointers>+]")
def stdint_cast(m) -> str:
    "Returns a string"
    return "(" + "".join(list(m)) + ")"


@mod.capture(rule="[<self.c_signed>] <self.c_types> [<self.c_pointers>]")
def c_variable(m) -> str:
    "Returns a string"
    return " ".join(list(m))


operators = Operators(
    SUBSCRIPT=create_described_insert_between("[", "]"),
    ASSIGNMENT=" = ",
    ASSIGNMENT_ADDITION=" += ",
    ASSIGNMENT_SUBTRACTION=" -= ",
    ASSIGNMENT_MULTIPLICATION=" *= ",
    ASSIGNMENT_DIVISION=" /= ",
    ASSIGNMENT_MODULO=" %= ",
    ASSIGNMENT_INCREMENT="++",
    ASSIGNMENT_BITWISE_AND=" &= ",
    ASSIGNMENT_BITWISE_OR=" |= ",
    ASSIGNMENT_BITWISE_EXCLUSIVE_OR=" ^= ",
    ASSIGNMENT_BITWISE_LEFT_SHIFT=" <<= ",
    ASSIGNMENT_BITWISE_RIGHT_SHIFT=" >>= ",
    BITWISE_AND=" & ",
    BITWISE_OR=" | ",
    BITWISE_NOT="~",
    BITWISE_EXCLUSIVE_OR=" ^ ",
    BITWISE_LEFT_SHIFT=" << ",
    BITWISE_RIGHT_SHIFT=" >> ",
    MATH_SUBTRACT=" - ",
    MATH_ADD=" + ",
    MATH_MULTIPLY=" * ",
    MATH_DIVIDE=" / ",
    MATH_MODULO=" % ",
    MATH_EQUAL=" == ",
    MATH_NOT_EQUAL=" != ",
    MATH_GREATER_THAN=" > ",
    MATH_GREATER_THAN_OR_EQUAL=" >= ",
    MATH_LESS_THAN=" < ",
    MATH_LESS_THAN_OR_EQUAL=" <= ",
    MATH_AND=" && ",
    MATH_OR=" || ",
    MATH_NOT="!",
    POINTER_INDIRECTION="*",
    POINTER_ADDRESS_OF="&",
    POINTER_STRUCTURE_DEREFERENCE="->",
)


@ctx.action_class("user")
class UserActions:
    def code_get_operators() -> Operators:
        return operators

    def code_insert_null():
        actions.auto_insert("NULL")

    def code_insert_is_null():
        actions.auto_insert(" == NULL ")

    def code_insert_is_not_null():
        actions.auto_insert(" != NULL")

    def code_insert_true():
        actions.auto_insert("true")

    def code_insert_false():
        actions.auto_insert("false")

    def code_insert_function(text: str, selection: str):
        if selection:
            text = text + f"({selection})"
        else:
            text = text + "()"

        actions.user.paste(text)
        actions.edit.left()

    # TODO - it would be nice that you integrate that types from c_cast
    # instead of defaulting to void
    def code_private_function(text: str):
        """Inserts private function declaration"""
        result = "void {}".format(
            actions.user.formatted_text(
                text, settings.get("user.code_private_function_formatter")
            )
        )

        actions.user.code_insert_function(result, None)

    def code_private_static_function(text: str):
        """Inserts private static function"""
        result = "static void {}".format(
            actions.user.formatted_text(
                text, settings.get("user.code_private_function_formatter")
            )
        )

        actions.user.code_insert_function(result, None)

    def code_insert_library(text: str, selection: str):
        actions.user.paste(f"#include <{text}>")



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\lang\cpp\cpp.py

- decorator inner: `rule="{user.cpp_standard_prefix} {user.cpp_standard_type}"`

- name: `<no explicit name>`

- raw rule: `{user.cpp_standard_prefix} {user.cpp_standard_type}`

- referenced lists:

  - `user.cpp_standard_prefix`: 
<unknown; not a literal in code>

  - `user.cpp_standard_type`: 
<unknown; not a literal in code>



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\lang\cpp\cpp.py

- decorator inner: `"user.code_type", rule="<user.c_types> | <user.cpp_standard_type>"`

- name: `<no explicit name>`

- raw rule: `<user.c_types> | <user.cpp_standard_type>`

- referenced lists:

  - `user.c_types`: 
<unknown; may be defined elsewhere>

  - `user.cpp_standard_type`: 
<unknown; may be defined elsewhere>



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\lang\lua\lua.py

- decorator inner: `rule="{self.lua_functions}"`

- name: `<no explicit name>`

- raw rule: `{self.lua_functions}`

- referenced lists:

  - `self.lua_functions`: 
<unknown; not a literal in code>



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\lang\rust\rust.py

- decorator inner: `"user.code_type", rule="[{user.code_type_modifier}] {user.code_type}"`

- name: `<no explicit name>`

- raw rule: `[{user.code_type_modifier}] {user.code_type}`

- referenced lists:

  - `user.code_type_modifier`: 
<unknown; not a literal in code>

  - `user.code_type`: 
{
    "int": "int",
    "float": "float",
    "string": "string",
    "bool": "bool",
    "array": "array",
    "null": "null",
    "void": "void",
}

operators = Operators(
    # code_operators_assignment
    ASSIGNMENT=" = ",
    ASSIGNMENT_ADDITION=" += ",
    ASSIGNMENT_SUBTRACTION=" -= ",
    ASSIGNMENT_MULTIPLICATION=" *= ",
    ASSIGNMENT_DIVISION=" /= ",
    ASSIGNMENT_MODULO=" %= ",
    ASSIGNMENT_INCREMENT="++",
    ASSIGNMENT_BITWISE_AND=" &= ",
    ASSIGNMENT_BITWISE_OR=" |= ",
    ASSIGNMENT_BITWISE_EXCLUSIVE_OR=" ^= ",
    ASSIGNMENT_BITWISE_LEFT_SHIFT=" <<= ",
    ASSIGNMENT_BITWISE_RIGHT_SHIFT=" >>= ",
    # code_operators_bitwise
    BITWISE_AND=" & ",
    BITWISE_OR=" | ",
    BITWISE_EXCLUSIVE_OR=" ^ ",
    BITWISE_LEFT_SHIFT=" << ",
    BITWISE_RIGHT_SHIFT=" >> ",
    BITWISE_NOT="~",
    # code_operators_math
    MATH_ADD=" + ",
    MATH_SUBTRACT=" - ",
    MATH_MULTIPLY=" * ",
    MATH_DIVIDE=" / ",
    MATH_MODULO=" % ",
    MATH_EXPONENT=" ** ",
    MATH_EQUAL=" === ",
    MATH_NOT_EQUAL=" !== ",
    MATH_WEAK_EQUAL=" == ",
    MATH_WEAK_NOT_EQUAL=" != ",
    MATH_GREATER_THAN=" > ",
    MATH_GREATER_THAN_OR_EQUAL=" >= ",
    MATH_LESS_THAN=" < ",
    MATH_LESS_THAN_OR_EQUAL=" <= ",
    MATH_NOT="!",
    MATH_AND=" && ",
    MATH_OR=" || ",
)


@ctx.action_class("user")
class UserActions:
    def code_get_operators() -> Operators:
        return operators

    def code_self():
        actions.auto_insert("$this")

    def code_operator_object_accessor():
        actions.auto_insert("->")

    def code_comment_block_prefix():
        actions.auto_insert("/*")

    def code_comment_block_suffix():
        actions.auto_insert("*/")

    def code_insert_true():
        actions.auto_insert("true")

    def code_insert_false():
        actions.auto_insert("false")

    def code_insert_null():
        actions.auto_insert("null")

    def code_insert_is_null():
        actions.auto_insert("is_null()")
        actions.edit.left()

    def code_insert_is_not_null():
        actions.auto_insert("isset()")
        actions.edit.left()

    def code_default_function(text: str):
        actions.user.code_public_function(text)

    def code_protected_function(text: str):
        """Inserts protected function declaration"""
        result = "protected function {}()".format(
            actions.user.formatted_text(
                text, settings.get("user.code_protected_function_formatter")
            )
        )
        actions.user.paste(result)
        actions.edit.left()

    def code_public_function(text: str):
        """Inserts public function declaration"""
        result = "public function {}()".format(
            actions.user.formatted_text(
                text, settings.get("user.code_public_function_formatter")
            )
        )
        actions.user.paste(result)
        actions.edit.left()

    def code_private_function(text: str):
        """Inserts private function declaration"""
        result = "private function {}()".format(
            actions.user.formatted_text(
                text, settings.get("user.code_public_function_formatter")
            )
        )
        actions.user.paste(result)
        actions.edit.left()

    def code_private_static_function(text: str):
        """Inserts private static function declaration"""
        result = "private static function {}()".format(
            actions.user.formatted_text(
                text, settings.get("user.code_protected_function_formatter")
            )
        )
        actions.user.paste(result)
        actions.edit.left()

    def code_protected_static_function(text: str):
        """Inserts protected static function declaration"""
        result = "protected static function {}()".format(
            actions.user.formatted_text(
                text, settings.get("user.code_protected_function_formatter")
            )
        )
        actions.user.paste(result)
        actions.edit.left()

    def code_public_static_function(text: str):
        """Inserts public static function declaration"""
        result = "public static function {}()".format(
            actions.user.formatted_text(
                text, settings.get("user.code_public_function_formatter")
            )
        )
        actions.user.paste(result)
        actions.edit.left()

    def code_insert_return_type(type: str):
        actions.insert(f": {type}")



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\lang\tags\functions.py

- decorator inner: `rule="{user.code_type}"`

- name: `<no explicit name>`

- raw rule: `{user.code_type}`

- referenced lists:

  - `user.code_type`: 
{
    "int": "int",
    "float": "float",
    "string": "string",
    "bool": "bool",
    "array": "array",
    "null": "null",
    "void": "void",
}

operators = Operators(
    # code_operators_assignment
    ASSIGNMENT=" = ",
    ASSIGNMENT_ADDITION=" += ",
    ASSIGNMENT_SUBTRACTION=" -= ",
    ASSIGNMENT_MULTIPLICATION=" *= ",
    ASSIGNMENT_DIVISION=" /= ",
    ASSIGNMENT_MODULO=" %= ",
    ASSIGNMENT_INCREMENT="++",
    ASSIGNMENT_BITWISE_AND=" &= ",
    ASSIGNMENT_BITWISE_OR=" |= ",
    ASSIGNMENT_BITWISE_EXCLUSIVE_OR=" ^= ",
    ASSIGNMENT_BITWISE_LEFT_SHIFT=" <<= ",
    ASSIGNMENT_BITWISE_RIGHT_SHIFT=" >>= ",
    # code_operators_bitwise
    BITWISE_AND=" & ",
    BITWISE_OR=" | ",
    BITWISE_EXCLUSIVE_OR=" ^ ",
    BITWISE_LEFT_SHIFT=" << ",
    BITWISE_RIGHT_SHIFT=" >> ",
    BITWISE_NOT="~",
    # code_operators_math
    MATH_ADD=" + ",
    MATH_SUBTRACT=" - ",
    MATH_MULTIPLY=" * ",
    MATH_DIVIDE=" / ",
    MATH_MODULO=" % ",
    MATH_EXPONENT=" ** ",
    MATH_EQUAL=" === ",
    MATH_NOT_EQUAL=" !== ",
    MATH_WEAK_EQUAL=" == ",
    MATH_WEAK_NOT_EQUAL=" != ",
    MATH_GREATER_THAN=" > ",
    MATH_GREATER_THAN_OR_EQUAL=" >= ",
    MATH_LESS_THAN=" < ",
    MATH_LESS_THAN_OR_EQUAL=" <= ",
    MATH_NOT="!",
    MATH_AND=" && ",
    MATH_OR=" || ",
)


@ctx.action_class("user")
class UserActions:
    def code_get_operators() -> Operators:
        return operators

    def code_self():
        actions.auto_insert("$this")

    def code_operator_object_accessor():
        actions.auto_insert("->")

    def code_comment_block_prefix():
        actions.auto_insert("/*")

    def code_comment_block_suffix():
        actions.auto_insert("*/")

    def code_insert_true():
        actions.auto_insert("true")

    def code_insert_false():
        actions.auto_insert("false")

    def code_insert_null():
        actions.auto_insert("null")

    def code_insert_is_null():
        actions.auto_insert("is_null()")
        actions.edit.left()

    def code_insert_is_not_null():
        actions.auto_insert("isset()")
        actions.edit.left()

    def code_default_function(text: str):
        actions.user.code_public_function(text)

    def code_protected_function(text: str):
        """Inserts protected function declaration"""
        result = "protected function {}()".format(
            actions.user.formatted_text(
                text, settings.get("user.code_protected_function_formatter")
            )
        )
        actions.user.paste(result)
        actions.edit.left()

    def code_public_function(text: str):
        """Inserts public function declaration"""
        result = "public function {}()".format(
            actions.user.formatted_text(
                text, settings.get("user.code_public_function_formatter")
            )
        )
        actions.user.paste(result)
        actions.edit.left()

    def code_private_function(text: str):
        """Inserts private function declaration"""
        result = "private function {}()".format(
            actions.user.formatted_text(
                text, settings.get("user.code_public_function_formatter")
            )
        )
        actions.user.paste(result)
        actions.edit.left()

    def code_private_static_function(text: str):
        """Inserts private static function declaration"""
        result = "private static function {}()".format(
            actions.user.formatted_text(
                text, settings.get("user.code_protected_function_formatter")
            )
        )
        actions.user.paste(result)
        actions.edit.left()

    def code_protected_static_function(text: str):
        """Inserts protected static function declaration"""
        result = "protected static function {}()".format(
            actions.user.formatted_text(
                text, settings.get("user.code_protected_function_formatter")
            )
        )
        actions.user.paste(result)
        actions.edit.left()

    def code_public_static_function(text: str):
        """Inserts public static function declaration"""
        result = "public static function {}()".format(
            actions.user.formatted_text(
                text, settings.get("user.code_public_function_formatter")
            )
        )
        actions.user.paste(result)
        actions.edit.left()

    def code_insert_return_type(type: str):
        actions.insert(f": {type}")



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\lang\tags\functions_common.py

- decorator inner: `rule="{user.code_common_function}"`

- name: `<no explicit name>`

- raw rule: `{user.code_common_function}`

- referenced lists:

  - `user.code_common_function`: 
{
    "integer": "int.TryParse",
    "print": "Console.WriteLine",
    "string": ".ToString",
    "length": ".Length",
    "order by": "OrderBy",
    "order by descending": "OrderByDescending",
    "then by": "ThenBy",
    "then by descending": "ThenByDescending",
    "include": "Include",
    "group by": "GroupBy",
    "select": "Select",
    "where": "Where",
    "first or default": "FirstOrDefault",
    "first": "First",
    "first or default async": "FirstOrDefaultAsync",
    "first async": "FirstAsync",
    "single or default": "SingleOrDefault",
    "contains": "Contains",
    "count": "Count",
    "to list": "ToList",
    "to list async": "ToListAsync",
    "to array": "ToArray",
    "to dictionary": "ToDictionary",
    "to lower": "ToLower",
    "to upper": "ToUpper",
    "trim": "Trim",
    "trim start": "TrimStart",
    "trim end": "TrimEnd",
    "substring": "Substring",
    "replace": "Replace",
    "split": "Split",
}

operators = Operators(
    # code_operators_array
    SUBSCRIPT=create_described_insert_between("[", "]"),
    # code_operators_assignment
    ASSIGNMENT=" = ",
    ASSIGNMENT_ADDITION=" += ",
    ASSIGNMENT_SUBTRACTION=" -= ",
    ASSIGNMENT_DIVISION=" /= ",
    ASSIGNMENT_MULTIPLICATION=" *= ",
    ASSIGNMENT_MODULO=" %= ",
    ASSIGNMENT_BITWISE_AND=" &= ",
    ASSIGNMENT_BITWISE_EXCLUSIVE_OR=" ^= ",
    ASSIGNMENT_BITWISE_LEFT_SHIFT=" <<= ",
    ASSIGNMENT_BITWISE_OR=" |= ",
    ASSIGNMENT_BITWISE_RIGHT_SHIFT=" >>= ",
    ASSIGNMENT_INCREMENT="++",
    # code_operators_bitwise
    BITWISE_NOT="~",
    BITWISE_AND=" & ",
    BITWISE_EXCLUSIVE_OR=" ^ ",
    BITWISE_LEFT_SHIFT=" << ",
    BITWISE_OR=" | ",
    BITWISE_RIGHT_SHIFT=" >> ",
    # code_operators_lambda
    LAMBDA="=>",
    # code_operators_pointer
    MATH_ADD=" + ",
    MATH_SUBTRACT=" - ",
    MATH_MULTIPLY=" * ",
    MATH_DIVIDE=" / ",
    MATH_MODULO=" % ",
    MATH_EQUAL=" == ",
    MATH_NOT_EQUAL=" != ",
    MATH_OR=" || ",
    MATH_AND=" && ",
    MATH_NOT="!",
    MATH_GREATER_THAN_OR_EQUAL=" >= ",
    MATH_GREATER_THAN=" > ",
    MATH_LESS_THAN_OR_EQUAL=" <= ",
    MATH_LESS_THAN=" < ",
    # code_operators_pointer
    POINTER_ADDRESS_OF="&",
    POINTER_INDIRECTION="*",
    POINTER_STRUCTURE_DEREFERENCE="->",
)


@ctx.action_class("user")
class UserActions:
    def code_get_operators() -> Operators:
        return operators

    def code_self():
        actions.auto_insert("this")

    def code_operator_object_accessor():
        actions.auto_insert(".")

    def code_insert_null():
        actions.auto_insert("null")

    def code_insert_is_null():
        actions.auto_insert(" == null ")

    def code_insert_is_not_null():
        actions.auto_insert(" != null")

    def code_insert_true():
        actions.auto_insert("true")

    def code_insert_false():
        actions.auto_insert("false")

    def code_insert_function(text: str, selection: str):
        text += f"({selection or ''})"
        actions.user.paste(text)
        actions.edit.left()

    def code_private_function(text: str):
        """Inserts private function declaration"""
        result = "private void {}".format(
            actions.user.formatted_text(
                text, settings.get("user.code_private_function_formatter")
            )
        )

        actions.user.code_insert_function(result, None)

    def code_private_static_function(text: str):
        """Inserts private static function"""
        result = "private static void {}".format(
            actions.user.formatted_text(
                text, settings.get("user.code_private_function_formatter")
            )
        )

        actions.user.code_insert_function(result, None)

    def code_protected_function(text: str):
        result = "private void {}".format(
            actions.user.formatted_text(
                text, settings.get("user.code_protected_function_formatter")
            )
        )

        actions.user.code_insert_function(result, None)

    def code_protected_static_function(text: str):
        result = "protected static void {}".format(
            actions.user.formatted_text(
                text, settings.get("user.code_protected_function_formatter")
            )
        )

        actions.user.code_insert_function(result, None)

    def code_public_function(text: str):
        result = "public void {}".format(
            actions.user.formatted_text(
                text, settings.get("user.code_public_function_formatter")
            )
        )

        actions.user.code_insert_function(result, None)

    def code_public_static_function(text: str):
        result = "public static void {}".format(
            actions.user.formatted_text(
                text, settings.get("user.code_public_function_formatter")
            )
        )

        actions.user.code_insert_function(result, None)



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\lang\tags\keywords.py

- decorator inner: `rule=("{user.code_keyword}|{user.code_keyword_unprefixed}"`

- name: `<no explicit name>`

- raw rule: `None`

- Resolved: none



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\lang\tags\libraries.py

- decorator inner: `rule="{user.code_libraries}"`

- name: `<no explicit name>`

- raw rule: `{user.code_libraries}`

- referenced lists:

  - `user.code_libraries`: 
{
    "bit": "bit",
    "I O": "io",
    "string": "string",
    "U T F eight": "utf8",
    "table": "table",
    "math": "math",
    "O S": "os",
    "debug": "debug",
    "L F S": "lfs",
    "socket": "socket",
    "H T T P": "http",
    "web": "http",
    "jason": "json",
}


@mod.capture(rule="{self.lua_functions}")
def lua_functions(m) -> str:
    "Returns a string"
    return m.lua_functions


###
# code_operators_bitwise
###


# NOTE: < 5.3 assumes Lua BitOp usage
#       > 5.2 assumes native bitwise operators
# ALSO NOTE: The documentation strings for these functions are used by help operators
# TODO: Possibly add settings to define which library to use, as 5.2
# includes bit32. Neovim uses luajit, which uses Lua BitOp
def code_operator_bitwise_and():
    "Insert & or library call based on user.lua_version"
    if settings.get("user.lua_version") > 5.2:
        actions.insert(" & ")
    else:
        actions.insert(" bit.band() ")


def code_operator_bitwise_or():
    "Insert | or library call based on user.lua_version"
    if settings.get("user.lua_version") > 5.2:
        actions.insert(" | ")
    else:
        actions.insert(" bit.bor() ")


def code_operator_bitwise_exclusive_or():
    "Insert ~ or library call based on user.lua_version"
    if settings.get("user.lua_version") > 5.2:
        actions.insert(" ~ ")
    else:
        actions.insert(" bit.xor() ")


def code_operator_bitwise_left_shift():
    "Insert << or library call based on user.lua_version"
    if settings.get("user.lua_version") > 5.2:
        actions.insert(" << ")
    else:
        actions.insert(" bit.lshift() ")


def code_operator_bitwise_right_shift():
    "Insert >> or library call based on user.lua_version"
    if settings.get("user.lua_version") > 5.2:
        actions.insert(" >> ")
    else:
        actions.insert(" bit.rshift() ")


operators = Operators(
    # code_operators_array
    SUBSCRIPT=create_described_insert_between("[", "]"),
    # code_operators_assignment
    ASSIGNMENT=" = ",
    # code_operators_bitwise
    BITWISE_AND=code_operator_bitwise_and,
    BITWISE_OR=code_operator_bitwise_or,
    BITWISE_EXCLUSIVE_OR=code_operator_bitwise_exclusive_or,
    BITWISE_LEFT_SHIFT=code_operator_bitwise_left_shift,
    BITWISE_RIGHT_SHIFT=code_operator_bitwise_right_shift,
    # code_operators_assignment
    MATH_SUBTRACT=" - ",
    MATH_ADD=" + ",
    MATH_MULTIPLY=" * ",
    MATH_DIVIDE=" / ",
    MATH_INTEGER_DIVIDE=" // ",
    MATH_MODULO=" % ",
    MATH_EXPONENT=" ^ ",
    MATH_EQUAL=" == ",
    MATH_NOT_EQUAL=" ~= ",
    MATH_GREATER_THAN=" > ",
    MATH_GREATER_THAN_OR_EQUAL=" >= ",
    MATH_LESS_THAN=" < ",
    MATH_LESS_THAN_OR_EQUAL=" <= ",
    MATH_AND=" and ",
    MATH_OR=" or ",
)


@ctx.action_class("user")
class UserActions:
    def code_get_operators() -> Operators:
        return operators

    # tag-related actions listed first, indicated by comment. corresponds to
    # the tag(): user.code_imperative style declaration in the language .talon
    # file

    ##
    # code_comment_block
    ##
    def code_comment_block_prefix():
        actions.insert("--[[")

    def code_comment_block_suffix():
        actions.insert("--]]")

    ##
    # code_data_bool
    ##
    def code_insert_true():
        actions.insert("true")

    def code_insert_false():
        actions.insert("false")

    ##
    # code_data_null
    ##
    def code_insert_null():
        actions.insert("nil")

    def code_insert_is_null():
        actions.insert(" == nil")

    def code_insert_is_not_null():
        actions.insert(" ~= nil")

    ##
    # code_functions
    ##
    def code_private_function(text: str):
        """Inserts private function declaration"""
        result = "local function {}".format(
            actions.user.formatted_text(
                text, settings.get("user.code_private_function_formatter")
            )
        )

        actions.insert("\n\nend")
        actions.key("up:2")
        actions.user.code_insert_function(result, None)

    def code_public_function(text: str):
        result = "function {}".format(
            actions.user.formatted_text(
                text, settings.get("user.code_public_function_formatter")
            )
        )

        actions.insert("\n\nend")
        actions.key("up:2")
        actions.user.code_insert_function(result, None)

    def code_insert_function(text: str, selection: str):
        if selection:
            text = text + f"({selection})"
        else:
            text = text + "()"

        actions.user.paste(text)
        actions.edit.left()

    ##
    # code_libraries
    ##
    def code_insert_library(text: str, selection: str):
        substitutions = {"1": selection, "0": selection}
        actions.user.insert_snippet_by_name("importStatement", substitutions)

    # non-tag related actions



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\lang\vimscript\vimscript.py

- decorator inner: `rule="{self.vimscript_functions}"`

- name: `<no explicit name>`

- raw rule: `{self.vimscript_functions}`

- referenced lists:

  - `self.vimscript_functions`: 
{
    "string len": "strlen",
    "get line": "getline",
    "set line": "setline",
    "length": "len",
}

ctx.lists["self.vimscript_scope"] = {
    "argument": "a:",
    "arg": "a:",
    "buffer": "b:",
    "buf": "b:",
    "window": "w:",
    "win": "w:",
    "tab": "t:",
    "special": "v:",
    "global": "g:",
    "local": "l:",
    "script local": "s:",
}

mod.list("vimscript_functions", desc="Standard built-in vimscript functions")
mod.list("vimscript_scope", desc="vimscript scoping types for functions and variables")


@mod.capture(rule="{self.vimscript_functions}")
def vimscript_functions(m) -> str:
    "Returns a string"
    return m.vimscript_functions


@mod.capture(rule="{self.vimscript_scope}")
def vimscript_scope(m) -> str:
    "Returns a string"
    return m.vimscript_scope


operators = Operators(
    # code_operators_assignment
    ASSIGNMENT=" = ",
    ASSIGNMENT_ADDITION=" += ",
    ASSIGNMENT_SUBTRACTION=" -= ",
    ASSIGNMENT_MULTIPLICATION=" *= ",
    ASSIGNMENT_DIVISION=" /= ",
    # code_operators_math
    MATH_ADD=" + ",
    MATH_SUBTRACT=" - ",
    MATH_MULTIPLY=" * ",
    MATH_DIVIDE=" / ",
)


def code_function_declaration(text: str, formatter: str):
    formatted_text = actions.user.formatted_text(text, settings.get(formatter))
    actions.user.insert_snippet_by_name("functionDeclaration", {"1": formatted_text})


@ctx.action_class("user")
class UserActions:
    def code_get_operators() -> Operators:
        return operators

    def code_private_function(text: str):
        code_function_declaration(text, "user.code_private_function_formatter")

    def code_protected_function(text: str):
        code_function_declaration(text, "user.code_protected_function_formatter")

    def code_public_function(text: str):
        code_function_declaration(text, "user.code_public_function_formatter")



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\lang\vimscript\vimscript.py

- decorator inner: `rule="{self.vimscript_scope}"`

- name: `<no explicit name>`

- raw rule: `{self.vimscript_scope}`

- referenced lists:

  - `self.vimscript_scope`: 
<unknown; not a literal in code>



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\abbreviate\abbreviate.py

- decorator inner: `rule="brief {user.abbreviation}"`

- name: `<no explicit name>`

- raw rule: `brief {user.abbreviation}`

- referenced lists:

  - `user.abbreviation`: 
abbreviations_list_with_values



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\app_switcher\app_switcher.py

- decorator inner: `rule="{self.running}"`

- name: `<no explicit name>`

- raw rule: `{self.running}`

- referenced lists:

  - `self.running`: 
running


def update_overrides(name, flags):
    """Updates the overrides and excludes lists"""
    global overrides, excludes

    if name is None or os.path.normcase(name) == override_file_path:
        overrides = {}
        excludes = set()

        # print("update_overrides")
        with open(override_file_path) as f:
            for line in f:
                line = line.rstrip().lower()
                line = line.split(",")
                if len(line) == 2 and line[0] != "Spoken form":
                    overrides[line[0]] = line[1].strip()
                if len(line) == 1:
                    excludes.add(line[0].strip())

        update_running_list()


@mod.action_class
class Actions:
    def get_running_app(name: str) -> ui.App:
        """Get the first available running app with `name`."""
        # We should use the capture result directly if it's already in the list
        # of running applications. Otherwise, name is from <user.text> and we
        # can be a bit fuzzier
        if name.lower() not in running_application_dict:
            if len(name) < 3:
                raise RuntimeError(
                    f'Skipped getting app: "{name}" has less than 3 chars.'
                )
            for running_name, full_application_name in ctx.lists[
                "self.running"
            ].items():
                if running_name == name or running_name.lower().startswith(
                    name.lower()
                ):
                    name = full_application_name
                    break
        for application in ui.apps(background=False):
            if application.name == name or (
                app.platform == "windows"
                and os.path.basename(application.exe).lower() == name
            ):
                return application
        raise RuntimeError(f'App not running: "{name}"')

    def switcher_focus(name: str):
        """Focus a new application by name"""
        app = actions.user.get_running_app(name)

        # Focus next window on same app
        if app == ui.active_app():
            actions.app.window_next()
        # Focus new app
        else:
            actions.user.switcher_focus_app(app)

    def switcher_focus_app(app: ui.App):
        """Focus application and wait until switch is made"""
        app.focus()
        t1 = time.perf_counter()
        while ui.active_app() != app:
            if time.perf_counter() - t1 > 1:
                raise RuntimeError(f"Can't focus app: {app.name}")
            actions.sleep(0.1)

    def switcher_focus_last():
        """Focus last window/application"""

    def switcher_focus_window(window: ui.Window):
        """Focus window and wait until switch is made"""
        window.focus()
        t1 = time.perf_counter()
        while ui.active_window() != window:
            if time.perf_counter() - t1 > 1:
                raise RuntimeError(f"Can't focus window: {window.title}")
            actions.sleep(0.1)

    def switcher_launch(path: str):
        """Launch a new application by path (all OSes), or AppUserModel_ID path on Windows"""
        if app.platform == "mac":
            ui.launch(path=path)
        elif app.platform == "linux":
            # Could potentially be merged with OSX code. Done in this explicit
            # way for expediency around the 0.4 release.
            cmd = shlex.split(path)[0]
            args = shlex.split(path)[1:]
            ui.launch(path=cmd, args=args)
        elif app.platform == "windows":
            is_valid_path = False
            try:
                current_path = Path(path)
                is_valid_path = current_path.is_file()
            except:
                is_valid_path = False
            if is_valid_path:
                ui.launch(path=path)
            else:
                cmd = f"explorer.exe shell:AppsFolder\\{path}"
                subprocess.Popen(cmd, shell=False)
        else:
            print("Unhandled platform in switcher_launch: " + app.platform)

    def switcher_menu():
        """Open a menu of running apps to switch to"""
        if app.platform == "windows":
            actions.key("alt-ctrl-tab")
        elif app.platform == "mac":
            # MacOS equivalent is "Mission Control"
            actions.user.dock_send_notification("com.apple.expose.awake")
        else:
            print("Persistent Switcher Menu not supported on " + app.platform)

    def switcher_toggle_running():
        """Shows/hides all running applications"""
        if gui_running.showing:
            gui_running.hide()
        else:
            gui_running.show()

    def switcher_hide_running():
        """Hides list of running applications"""
        gui_running.hide()


@imgui.open()
def gui_running(gui: imgui.GUI):
    gui.text("Running applications (with spoken forms)")
    gui.line()
    running_apps = sorted(
        (v.lower(), k, v) for k, v in ctx.lists["self.running"].items()
    )
    for _, running_name, full_application_name in running_apps:
        gui.text(f"{full_application_name}: {running_name}")

    gui.spacer()
    if gui.button("Running close"):
        actions.user.switcher_hide_running()


def update_launch_list():
    launch = get_apps()

    # actions.user.talon_pretty_print(launch)

    ctx.lists["self.launch"] = actions.user.create_spoken_forms_from_map(
        launch, words_to_exclude
    )


def ui_event(event, arg):
    if event in ("app_launch", "app_close"):
        update_running_list()


# Talon starts faster if you don't use the `talon.ui` module during launch


def on_ready():
    update_overrides(None, None)
    fs.watch(overrides_directory, update_overrides)
    update_launch_list()
    update_running_list()
    ui.register("", ui_event)


app.register("ready", on_ready)



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\app_switcher\app_switcher.py

- decorator inner: `rule="{self.launch}"`

- name: `<no explicit name>`

- raw rule: `{self.launch}`

- referenced lists:

  - `self.launch`: 
<unknown; not a literal in code>



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\contacts\contacts.py

- decorator inner: `rule="{user.contact_names} name",`

- name: `<no explicit name>`

- raw rule: `{user.contact_names} name`

- referenced lists:

  - `user.contact_names`: 
contact_names
    ctx.lists["user.contact_emails"] = contact_emails
    ctx.lists["user.contact_full_names"] = contact_full_names


def first_name_from_full_name(full_name: str):
    return full_name.split(" ")[0]


def last_name_from_full_name(full_name: str):
    return full_name.split(" ")[-1]


def username_from_email(email: str):
    return email.split("@")[0]


def make_name_possessive(name: str):
    return f"{name}'s"


@mod.capture(
    rule="{user.contact_names} name",
)
def prose_name(m) -> str:
    return m.contact_names


@mod.capture(
    rule="{user.contact_names} names",
)
def prose_name_possessive(m) -> str:
    return make_name_possessive(m.contact_names)


@mod.capture(
    rule="{user.contact_emails} email [address]",
)
def prose_email(m) -> str:
    return m.contact_emails


@mod.capture(
    rule="{user.contact_emails} (username | L dap)",
)
def prose_username(m) -> str:
    return username_from_email(m.contact_emails)


@mod.capture(
    rule="{user.contact_full_names} full name",
)
def prose_full_name(m) -> str:
    return m.contact_full_names


@mod.capture(
    rule="{user.contact_full_names} full names",
)
def prose_full_name_possessive(m) -> str:
    return make_name_possessive(m.contact_full_names)


@mod.capture(
    rule="{user.contact_full_names} first name",
)
def prose_first_name(m) -> str:
    return first_name_from_full_name(m.contact_full_names)


@mod.capture(
    rule="{user.contact_full_names} first names",
)
def prose_first_name_possessive(m) -> str:
    return make_name_possessive(first_name_from_full_name(m.contact_full_names))


@mod.capture(
    rule="{user.contact_full_names} last name",
)
def prose_last_name(m) -> str:
    return last_name_from_full_name(m.contact_full_names)


@mod.capture(
    rule="{user.contact_full_names} last names",
)
def prose_last_name_possessive(m) -> str:
    return make_name_possessive(last_name_from_full_name(m.contact_full_names))


@mod.capture(
    rule="(hi | high) {user.contact_names} [name]",
)
def prose_contact_snippet(m) -> str:
    return f"hi {m.contact_names}"


@mod.capture(
    rule=(
        "<user.prose_name> "
        "| <user.prose_name_possessive> "
        "| <user.prose_email> "
        "| <user.prose_username> "
        "| <user.prose_full_name> "
        "| <user.prose_full_name_possessive> "
        "| <user.prose_first_name> "
        "| <user.prose_first_name_possessive> "
        "| <user.prose_last_name>"
        "| <user.prose_last_name_possessive>"
        "| <user.prose_contact_snippet>"
    ),
)
def prose_contact(m) -> str:
    return m[0]



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\contacts\contacts.py

- decorator inner: `rule="{user.contact_names} names",`

- name: `<no explicit name>`

- raw rule: `{user.contact_names} names`

- referenced lists:

  - `user.contact_names`: 
contact_names
    ctx.lists["user.contact_emails"] = contact_emails
    ctx.lists["user.contact_full_names"] = contact_full_names


def first_name_from_full_name(full_name: str):
    return full_name.split(" ")[0]


def last_name_from_full_name(full_name: str):
    return full_name.split(" ")[-1]


def username_from_email(email: str):
    return email.split("@")[0]


def make_name_possessive(name: str):
    return f"{name}'s"


@mod.capture(
    rule="{user.contact_names} name",
)
def prose_name(m) -> str:
    return m.contact_names


@mod.capture(
    rule="{user.contact_names} names",
)
def prose_name_possessive(m) -> str:
    return make_name_possessive(m.contact_names)


@mod.capture(
    rule="{user.contact_emails} email [address]",
)
def prose_email(m) -> str:
    return m.contact_emails


@mod.capture(
    rule="{user.contact_emails} (username | L dap)",
)
def prose_username(m) -> str:
    return username_from_email(m.contact_emails)


@mod.capture(
    rule="{user.contact_full_names} full name",
)
def prose_full_name(m) -> str:
    return m.contact_full_names


@mod.capture(
    rule="{user.contact_full_names} full names",
)
def prose_full_name_possessive(m) -> str:
    return make_name_possessive(m.contact_full_names)


@mod.capture(
    rule="{user.contact_full_names} first name",
)
def prose_first_name(m) -> str:
    return first_name_from_full_name(m.contact_full_names)


@mod.capture(
    rule="{user.contact_full_names} first names",
)
def prose_first_name_possessive(m) -> str:
    return make_name_possessive(first_name_from_full_name(m.contact_full_names))


@mod.capture(
    rule="{user.contact_full_names} last name",
)
def prose_last_name(m) -> str:
    return last_name_from_full_name(m.contact_full_names)


@mod.capture(
    rule="{user.contact_full_names} last names",
)
def prose_last_name_possessive(m) -> str:
    return make_name_possessive(last_name_from_full_name(m.contact_full_names))


@mod.capture(
    rule="(hi | high) {user.contact_names} [name]",
)
def prose_contact_snippet(m) -> str:
    return f"hi {m.contact_names}"


@mod.capture(
    rule=(
        "<user.prose_name> "
        "| <user.prose_name_possessive> "
        "| <user.prose_email> "
        "| <user.prose_username> "
        "| <user.prose_full_name> "
        "| <user.prose_full_name_possessive> "
        "| <user.prose_first_name> "
        "| <user.prose_first_name_possessive> "
        "| <user.prose_last_name>"
        "| <user.prose_last_name_possessive>"
        "| <user.prose_contact_snippet>"
    ),
)
def prose_contact(m) -> str:
    return m[0]



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\contacts\contacts.py

- decorator inner: `rule="{user.contact_emails} email [address]",`

- name: `<no explicit name>`

- raw rule: `{user.contact_emails} email [address]`

- referenced lists:

  - `user.contact_emails`: 
<unknown; not a literal in code>



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\contacts\contacts.py

- decorator inner: `rule="{user.contact_emails} (username | L dap`

- name: `<no explicit name>`

- raw rule: `None`

- Resolved: none



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\contacts\contacts.py

- decorator inner: `rule="{user.contact_full_names} full name",`

- name: `<no explicit name>`

- raw rule: `{user.contact_full_names} full name`

- referenced lists:

  - `user.contact_full_names`: 
<unknown; not a literal in code>



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\contacts\contacts.py

- decorator inner: `rule="{user.contact_full_names} full names",`

- name: `<no explicit name>`

- raw rule: `{user.contact_full_names} full names`

- referenced lists:

  - `user.contact_full_names`: 
<unknown; not a literal in code>



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\contacts\contacts.py

- decorator inner: `rule="{user.contact_full_names} first name",`

- name: `<no explicit name>`

- raw rule: `{user.contact_full_names} first name`

- referenced lists:

  - `user.contact_full_names`: 
<unknown; not a literal in code>



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\contacts\contacts.py

- decorator inner: `rule="{user.contact_full_names} first names",`

- name: `<no explicit name>`

- raw rule: `{user.contact_full_names} first names`

- referenced lists:

  - `user.contact_full_names`: 
<unknown; not a literal in code>



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\contacts\contacts.py

- decorator inner: `rule="{user.contact_full_names} last name",`

- name: `<no explicit name>`

- raw rule: `{user.contact_full_names} last name`

- referenced lists:

  - `user.contact_full_names`: 
<unknown; not a literal in code>



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\contacts\contacts.py

- decorator inner: `rule="{user.contact_full_names} last names",`

- name: `<no explicit name>`

- raw rule: `{user.contact_full_names} last names`

- referenced lists:

  - `user.contact_full_names`: 
<unknown; not a literal in code>



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\contacts\contacts.py

- decorator inner: `rule="(hi | high`

- name: `<no explicit name>`

- raw rule: `None`

- Resolved: none



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\contacts\contacts.py

- decorator inner: `rule=(
        "<user.prose_name> "
        "| <user.prose_name_possessive> "
        "| <user.prose_email> "
        "| <user.prose_username> "
        "| <user.prose_full_name> "
        "| <user.prose_full_name_possessive> "
        "| <user.prose_first_name> "
        "| <user.prose_first_name_possessive> "
        "| <user.prose_last_name>"
        "| <user.prose_last_name_possessive>"
        "| <user.prose_contact_snippet>"`

- name: `<no explicit name>`

- raw rule: `None`

- Resolved: none



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\edit\delimiter_pair.py

- decorator inner: `rule="{user.delimiter_pair}"`

- name: `<no explicit name>`

- raw rule: `{user.delimiter_pair}`

- referenced lists:

  - `user.delimiter_pair`: 
<unknown; not a literal in code>



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\edit\edit_command_actions.py

- decorator inner: `rule="{user.edit_action}"`

- name: `<no explicit name>`

- raw rule: `{user.edit_action}`

- referenced lists:

  - `user.edit_action`: 
<unknown; not a literal in code>



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\edit\edit_command_actions.py

- decorator inner: `rule="<user.delimiter_pair> wrap"`

- name: `<no explicit name>`

- raw rule: `<user.delimiter_pair> wrap`

- referenced lists:

  - `user.delimiter_pair`: 
<unknown; may be defined elsewhere>



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\edit\edit_command_actions.py

- decorator inner: `rule="<user.formatters> format"`

- name: `<no explicit name>`

- raw rule: `<user.formatters> format`

- referenced lists:

  - `user.formatters`: 
<unknown; may be defined elsewhere>



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\edit\edit_command_actions.py

- decorator inner: `rule="<user.edit_simple_action> | <user.edit_wrap_action> | <user.edit_format_action>"`

- name: `<no explicit name>`

- raw rule: `<user.edit_simple_action> | <user.edit_wrap_action> | <user.edit_format_action>`

- referenced lists:

  - `user.edit_simple_action`: 
<unknown; may be defined elsewhere>

  - `user.edit_wrap_action`: 
<unknown; may be defined elsewhere>

  - `user.edit_format_action`: 
<unknown; may be defined elsewhere>



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\edit\edit_command_modifiers.py

- decorator inner: `rule="({user.edit_modifier}`

- name: `<no explicit name>`

- raw rule: `None`

- Resolved: none



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\edit\edit_navigation_steps.py

- decorator inner: `rule="[<number_small>] {user.edit_modifier_repeatable}"`

- name: `<no explicit name>`

- raw rule: `[<number_small>] {user.edit_modifier_repeatable}`

- referenced lists:

  - `user.edit_modifier_repeatable`: 
<unknown; not a literal in code>

  - `number_small`: 
<defined via mod.list>



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\formatters\formatters.py

- decorator inner: `rule="({user.code_formatter} | {user.prose_formatter} | {user.reformatter}`

- name: `<no explicit name>`

- raw rule: `None`

- Resolved: none



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\formatters\formatters.py

- decorator inner: `rule="{self.code_formatter}+"`

- name: `<no explicit name>`

- raw rule: `{self.code_formatter}+`

- referenced lists:

  - `self.code_formatter`: 
<unknown; not a literal in code>



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\formatters\formatters.py

- decorator inner: `rule="<self.formatters> <user.text> (<user.text> | <user.formatter_immune>`

- name: `<no explicit name>`

- raw rule: `None`

- Resolved: none



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\formatters\formatters.py

- decorator inner: `rule="<user.code_formatters> <user.text>"`

- name: `<no explicit name>`

- raw rule: `<user.code_formatters> <user.text>`

- referenced lists:

  - `user.code_formatters`: 
<unknown; may be defined elsewhere>

  - `user.text`: 
<unknown; may be defined elsewhere>



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\formatters\formatters.py

- decorator inner: `# Add anything else into this that you want to have inserted when
    # using a prose formatter.
    rule="(<user.symbol_key> | (numb | numeral`

- name: `<no explicit name>`

- raw rule: `None`

- Resolved: none



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\homophones\homophones.py

- decorator inner: `rule="{self.homophones_canonicals}"`

- name: `<no explicit name>`

- raw rule: `{self.homophones_canonicals}`

- referenced lists:

  - `self.homophones_canonicals`: 
canonical_list


update_homophones(homophones_file, None)
fs.watch(cwd, update_homophones)
active_word_list = None
is_selection = False


def close_homophones():
    gui.hide()
    ctx.tags = []


PHONES_FORMATTERS = [
    lambda word: word.capitalize(),
    lambda word: word.upper(),
]


def find_matching_format_function(word_with_formatting, format_functions):
    """Finds the formatter function from a list of formatter functions which transforms a word into itself.
    Returns an identity function if none exists"""
    for formatter in format_functions:
        formatted_word = formatter(word_with_formatting)
        if word_with_formatting == formatted_word:
            return formatter

    return lambda word: word


def raise_homophones(word_to_find_homophones_for, forced=False, selection=False):
    global quick_replace
    global active_word_list
    global show_help
    global force_raise
    global is_selection

    force_raise = forced
    is_selection = selection

    if is_selection:
        word_to_find_homophones_for = word_to_find_homophones_for.strip()
    formatter = find_matching_format_function(
        word_to_find_homophones_for, PHONES_FORMATTERS
    )

    word_to_find_homophones_for = word_to_find_homophones_for.lower()

    # We support plurals, but very naively. If we can't find your word but your word ends in an s, presume its plural
    # and attempt to find the singular, then present the presumed plurals back. This could be improved!
    if word_to_find_homophones_for in all_homophones:
        valid_homophones = all_homophones[word_to_find_homophones_for]
    elif (
        word_to_find_homophones_for.endswith("s")
        and word_to_find_homophones_for[:-1] in all_homophones
    ):
        valid_homophones = map(
            lambda w: w + "s", all_homophones[word_to_find_homophones_for[:-1]]
        )
    else:
        app.notify(
            "homophones.py", f'"{word_to_find_homophones_for}" not in homophones list'
        )
        return

    # Move current word to end of list to reduce searcher's cognitive load
    valid_homophones_reordered = list(
        filter(
            lambda word_from_list: word_from_list.lower()
            != word_to_find_homophones_for,
            valid_homophones,
        )
    ) + [word_to_find_homophones_for]
    active_word_list = list(map(formatter, valid_homophones_reordered))

    if (
        is_selection
        and len(active_word_list) == 2
        and quick_replace
        and not force_raise
    ):
        if word_to_find_homophones_for == active_word_list[0].lower():
            new = active_word_list[1]
        else:
            new = active_word_list[0]

        clip.set(new)
        actions.edit.paste()
        return

    ctx.tags = ["user.homophones_open"]
    show_help = False
    gui.show()


@imgui.open(x=main_screen.x + main_screen.width / 2.6, y=main_screen.y)
def gui(gui: imgui.GUI):
    global active_word_list
    if show_help:
        gui.text("Homophone help - todo")
    else:
        gui.text("Select a homophone")
        gui.line()
        index = 1
        for word in active_word_list:
            if gui.button(f"Choose {index}: {word}"):
                actions.insert(actions.user.homophones_select(index))
                actions.user.homophones_hide()
            index = index + 1

        if gui.button("Phones (hide | exit)"):
            actions.user.homophones_hide()


def show_help_gui():
    global show_help
    show_help = True
    gui.show()


@mod.capture(rule="{self.homophones_canonicals}")
def homophones_canonical(m) -> str:
    "Returns a single string"
    return m.homophones_canonicals


@mod.action_class
class Actions:
    def homophones_hide():
        """Hides the homophones display"""
        close_homophones()

    def homophones_show(m: str):
        """Show the homophones display"""
        raise_homophones(m, False, False)

    def homophones_show_auto():
        """Show homophones for selection, or current word if selection is empty."""
        text = actions.edit.selected_text()
        if text:
            raise_homophones(text, False, True)
        else:
            actions.edit.select_word()
            actions.user.homophones_show_selection()

    def homophones_show_selection():
        """Show the homophones display for the selected text"""
        raise_homophones(actions.edit.selected_text(), False, True)

    def homophones_force_show(m: str):
        """Show the homophones display forcibly"""
        raise_homophones(m, True, False)

    def homophones_force_show_selection():
        """Show the homophones display for the selected text forcibly"""
        raise_homophones(actions.edit.selected_text(), True, True)

    def homophones_select(number: int) -> str:
        """selects the homophone by number"""
        if number <= len(active_word_list) and number > 0:
            return active_word_list[number - 1]

        error = "homophones.py index {} is out of range (1-{})".format(
            number, len(active_word_list)
        )
        app.notify(error)
        raise error

    def homophones_get(word: str) -> [str] or None:
        """Get homophones for the given word"""
        word = word.lower()
        if word in all_homophones:
            return all_homophones[word]
        return None


ctx_homophones_open = Context()
ctx_homophones_open.matches = """
tag: user.homophones_open
"""


@ctx_homophones_open.action_class("user")
class UserActions:
    def choose(number_small: int):
        """Choose the nth homophone"""
        result = actions.user.homophones_select(number_small)
        actions.insert(result)
        actions.user.homophones_hide()



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\keys\keys.py

- decorator inner: `rule="{self.modifier_key}+"`

- name: `<no explicit name>`

- raw rule: `{self.modifier_key}+`

- referenced lists:

  - `self.modifier_key`: 
<unknown; not a literal in code>



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\keys\keys.py

- decorator inner: `rule="{self.arrow_key}"`

- name: `<no explicit name>`

- raw rule: `{self.arrow_key}`

- referenced lists:

  - `self.arrow_key`: 
<unknown; not a literal in code>



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\keys\keys.py

- decorator inner: `rule="<self.arrow_key>+"`

- name: `<no explicit name>`

- raw rule: `<self.arrow_key>+`

- referenced lists:

  - `self.arrow_key`: 
<unknown; may be defined elsewhere>



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\keys\keys.py

- decorator inner: `rule="{self.number_key}"`

- name: `<no explicit name>`

- raw rule: `{self.number_key}`

- referenced lists:

  - `self.number_key`: 
<unknown; not a literal in code>



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\keys\keys.py

- decorator inner: `rule="{self.keypad_key}"`

- name: `<no explicit name>`

- raw rule: `{self.keypad_key}`

- referenced lists:

  - `self.keypad_key`: 
<unknown; not a literal in code>



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\keys\keys.py

- decorator inner: `rule="{self.letter}"`

- name: `<no explicit name>`

- raw rule: `{self.letter}`

- referenced lists:

  - `self.letter`: 
<unknown; not a literal in code>



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\keys\keys.py

- decorator inner: `rule="{self.special_key}"`

- name: `<no explicit name>`

- raw rule: `{self.special_key}`

- referenced lists:

  - `self.special_key`: 
<unknown; not a literal in code>



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\keys\keys.py

- decorator inner: `rule="{self.symbol_key}"`

- name: `<no explicit name>`

- raw rule: `{self.symbol_key}`

- referenced lists:

  - `self.symbol_key`: 
<unknown; not a literal in code>



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\keys\keys.py

- decorator inner: `rule="{self.function_key}"`

- name: `<no explicit name>`

- raw rule: `{self.function_key}`

- referenced lists:

  - `self.function_key`: 
<unknown; not a literal in code>



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\keys\keys.py

- decorator inner: `rule="( <self.letter> | <self.number_key> | <self.symbol_key>`

- name: `<no explicit name>`

- raw rule: `None`

- Resolved: none



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\keys\keys.py

- decorator inner: `rule="( <self.letter> | <self.number_key> | <self.symbol_key> "
    "| <self.arrow_key> | <self.function_key> | <self.special_key> | <self.keypad_key>`

- name: `<no explicit name>`

- raw rule: `( <self.letter> | <self.number_key> | <self.symbol_key> `

- referenced lists:

  - `self.letter`: 
<unknown; may be defined elsewhere>

  - `self.number_key`: 
<unknown; may be defined elsewhere>

  - `self.symbol_key`: 
<unknown; may be defined elsewhere>



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\keys\keys.py

- decorator inner: `rule="{self.modifier_key}* <self.unmodified_key>"`

- name: `<no explicit name>`

- raw rule: `{self.modifier_key}* <self.unmodified_key>`

- referenced lists:

  - `self.modifier_key`: 
<unknown; not a literal in code>

  - `self.unmodified_key`: 
<unknown; may be defined elsewhere>



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\keys\keys.py

- decorator inner: `rule="<self.key>+"`

- name: `<no explicit name>`

- raw rule: `<self.key>+`

- referenced lists:

  - `self.key`: 
<unknown; may be defined elsewhere>



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\keys\keys.py

- decorator inner: `rule="{self.letter}+"`

- name: `<no explicit name>`

- raw rule: `{self.letter}+`

- referenced lists:

  - `self.letter`: 
<unknown; not a literal in code>



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\numbers\numbers.py

- decorator inner: `"digit_string", rule=f"({alt_digits} | {alt_teens} | {alt_tens}`

- name: `digit_string`

- raw rule: `None`

- Resolved: none



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\numbers\numbers.py

- decorator inner: `"digits", rule="<digit_string>"`

- name: `<no explicit name>`

- raw rule: `<digit_string>`

- referenced lists:

  - `digit_string`: 
<unknown; may be defined elsewhere>



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\numbers\numbers.py

- decorator inner: `rule=f"{number_word_leading} ([and] {number_word}`

- name: `<no explicit name>`

- raw rule: `None`

- Resolved: none



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\numbers\numbers.py

- decorator inner: `"number", rule="<user.number_string>"`

- name: `<no explicit name>`

- raw rule: `<user.number_string>`

- referenced lists:

  - `user.number_string`: 
<unknown; may be defined elsewhere>



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\numbers\numbers.py

- decorator inner: `rule="[negative | minus] <user.number_string>"`

- name: `<no explicit name>`

- raw rule: `[negative | minus] <user.number_string>`

- referenced lists:

  - `user.number_string`: 
<unknown; may be defined elsewhere>



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\numbers\numbers.py

- decorator inner: `"number_signed", rule="<user.number_signed_string>"`

- name: `<no explicit name>`

- raw rule: `<user.number_signed_string>`

- referenced lists:

  - `user.number_signed_string`: 
<unknown; may be defined elsewhere>



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\numbers\numbers.py

- decorator inner: `rule="<user.number_string> ((dot | point`

- name: `<no explicit name>`

- raw rule: `None`

- Resolved: none



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\numbers\numbers.py

- decorator inner: `rule="<user.number_string> (comma <user.number_string>`

- name: `<no explicit name>`

- raw rule: `None`

- Resolved: none



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\numbers\numbers.py

- decorator inner: `rule="<user.number_string> (colon <user.number_string>`

- name: `<no explicit name>`

- raw rule: `None`

- Resolved: none



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\numbers\numbers.py

- decorator inner: `rule="<user.number_signed_string> | <user.number_prose_with_dot> | <user.number_prose_with_comma> | <user.number_prose_with_colon>"`

- name: `<no explicit name>`

- raw rule: `<user.number_signed_string> | <user.number_prose_with_dot> | <user.number_prose_with_comma> | <user.number_prose_with_colon>`

- referenced lists:

  - `user.number_signed_string`: 
<unknown; may be defined elsewhere>

  - `user.number_prose_with_dot`: 
<unknown; may be defined elsewhere>

  - `user.number_prose_with_comma`: 
<unknown; may be defined elsewhere>

  - `user.number_prose_with_colon`: 
<unknown; may be defined elsewhere>



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\numbers\numbers.py

- decorator inner: `rule="(numb | numeral`

- name: `<no explicit name>`

- raw rule: `None`

- Resolved: none



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\numbers\numbers.py

- decorator inner: `"number_small", rule="{user.number_small}"`

- name: `<no explicit name>`

- raw rule: `{user.number_small}`

- referenced lists:

  - `user.number_small`: 
get_spoken_form_under_one_hundred(
    0,
    99,
    include_default_variant_for_single_digits=True,
    include_double_digits=True,
)


# TODO: allow things like "double eight" for 88
@ctx.capture("digit_string", rule=f"({alt_digits} | {alt_teens} | {alt_tens})+")
def digit_string(m) -> str:
    return parse_number(list(m))


@ctx.capture("digits", rule="<digit_string>")
def digits(m) -> int:
    """Parses a phrase representing a digit sequence, returning it as an integer."""
    return int(m.digit_string)


@mod.capture(rule=f"{number_word_leading} ([and] {number_word})*")
def number_string(m) -> str:
    """Parses a number phrase, returning that number as a string."""
    return parse_number(list(m))


@ctx.capture("number", rule="<user.number_string>")
def number(m) -> int:
    """Parses a number phrase, returning it as an integer."""
    return int(m.number_string)


@mod.capture(rule="[negative | minus] <user.number_string>")
def number_signed_string(m) -> str:
    """Parses a (possibly negative) number phrase, returning that number as a string."""
    number = m.number_string
    return f"-{number}" if (m[0] in ["negative", "minus"]) else number


@ctx.capture("number_signed", rule="<user.number_signed_string>")
def number_signed(m) -> int:
    """Parses a (possibly negative) number phrase, returning that number as a integer."""
    return int(m.number_signed_string)


@mod.capture(rule="<user.number_string> ((dot | point) <user.number_string>)+")
def number_prose_with_dot(m) -> str:
    return ".".join(m.number_string_list)


@mod.capture(rule="<user.number_string> (comma <user.number_string>)+")
def number_prose_with_comma(m) -> str:
    return ",".join(m.number_string_list)


@mod.capture(rule="<user.number_string> (colon <user.number_string>)+")
def number_prose_with_colon(m) -> str:
    return ":".join(m.number_string_list)


@mod.capture(
    rule="<user.number_signed_string> | <user.number_prose_with_dot> | <user.number_prose_with_comma> | <user.number_prose_with_colon>"
)
def number_prose_unprefixed(m) -> str:
    return m[0]


@mod.capture(rule="(numb | numeral) <user.number_prose_unprefixed>")
def number_prose_prefixed(m) -> str:
    return m.number_prose_unprefixed


@ctx.capture("number_small", rule="{user.number_small}")
def number_small(m) -> int:
    return int(m.number_small)


@mod.capture(rule="[negative | minus] <number_small>")
def number_signed_small(m) -> int:
    """Parses an integer between -99 and 99."""
    number = m[-1]
    return -number if (m[0] in ["negative", "minus"]) else number



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\numbers\numbers.py

- decorator inner: `rule="[negative | minus] <number_small>"`

- name: `<no explicit name>`

- raw rule: `[negative | minus] <number_small>`

- referenced lists:

  - `number_small`: 
<defined via mod.list>



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\numbers\ordinals.py

- decorator inner: `rule="{user.ordinals}"`

- name: `<no explicit name>`

- raw rule: `{user.ordinals}`

- referenced lists:

  - `user.ordinals`: 
ordinal_numbers
ctx.lists["user.ordinals_small"] = ordinal_small


@mod.capture(rule="{user.ordinals}")
def ordinals(m) -> int:
    """Returns a single ordinal as an integer"""
    return int(m.ordinals)


@mod.capture(rule="{user.ordinals_small}")
def ordinals_small(m) -> int:
    """Returns a single small ordinal as an integer"""
    return int(m.ordinals_small)



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\numbers\ordinals.py

- decorator inner: `rule="{user.ordinals_small}"`

- name: `<no explicit name>`

- raw rule: `{user.ordinals_small}`

- referenced lists:

  - `user.ordinals_small`: 
<unknown; not a literal in code>



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\text\text_and_dictation.py

- decorator inner: `rule="{user.prose_modifiers}"`

- name: `<no explicit name>`

- raw rule: `{user.prose_modifiers}`

- referenced lists:

  - `user.prose_modifiers`: 
<unknown; not a literal in code>



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\text\text_and_dictation.py

- decorator inner: `rule="<user.number_string> [(dot | point`

- name: `<no explicit name>`

- raw rule: `None`

- Resolved: none



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\text\text_and_dictation.py

- decorator inner: `rule="<user.number_string> {user.currency} [[and] <user.number_string> [cents|pence]]"`

- name: `<no explicit name>`

- raw rule: `<user.number_string> {user.currency} [[and] <user.number_string> [cents|pence]]`

- referenced lists:

  - `user.currency`: 
<unknown; not a literal in code>

  - `user.number_string`: 
<unknown; may be defined elsewhere>



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\text\text_and_dictation.py

- decorator inner: `rule="am|pm"`

- name: `<no explicit name>`

- raw rule: `am|pm`

- literal alternatives: am, pm



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\text\text_and_dictation.py

- decorator inner: `rule="{user.hours} ({user.minutes} | o'clock | hundred hours`

- name: `<no explicit name>`

- raw rule: `None`

- Resolved: none



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\text\text_and_dictation.py

- decorator inner: `rule="{user.hours_twelve} <user.time_am_pm>"`

- name: `<no explicit name>`

- raw rule: `{user.hours_twelve} <user.time_am_pm>`

- referenced lists:

  - `user.hours_twelve`: 
get_spoken_form_under_one_hundred(
    1,
    12,
    include_oh_variant_for_single_digits=True,
    include_default_variant_for_single_digits=True,
)
ctx.lists["user.hours"] = get_spoken_form_under_one_hundred(
    1,
    23,
    include_oh_variant_for_single_digits=True,
    include_default_variant_for_single_digits=True,
)
ctx.lists["user.minutes"] = get_spoken_form_under_one_hundred(
    1,
    59,
    include_oh_variant_for_single_digits=True,
    include_default_variant_for_single_digits=False,
)


@mod.capture(rule="{user.prose_modifiers}")
def prose_modifier(m) -> Callable:
    return getattr(DictationFormat, m.prose_modifiers)


@mod.capture(
    rule="<user.number_string> [(dot | point) <digit_string>] percent [sign|sine]"
)
def prose_percent(m) -> str:
    s = m.number_string
    if hasattr(m, "digit_string"):
        s += "." + m.digit_string
    return s + "%"


@mod.capture(
    rule="<user.number_string> {user.currency} [[and] <user.number_string> [cents|pence]]"
)
def prose_currency(m) -> str:
    s = m.currency + m.number_string_1
    if hasattr(m, "number_string_2"):
        s += "." + m.number_string_2
    return s


@mod.capture(rule="am|pm")
def time_am_pm(m) -> str:
    return str(m)


# this matches eg "twelve thirty-four" -> 12:34 and "twelve hundred" -> 12:00. hmmmmm.
@mod.capture(
    rule="{user.hours} ({user.minutes} | o'clock | hundred hours) [<user.time_am_pm>]"
)
def prose_time_hours_minutes(m) -> str:
    t = m.hours + ":"
    if hasattr(m, "minutes"):
        t += m.minutes
    else:
        t += "00"
    if hasattr(m, "time_am_pm"):
        t += m.time_am_pm
    return t


@mod.capture(rule="{user.hours_twelve} <user.time_am_pm>")
def prose_time_hours_am_pm(m) -> str:
    return m.hours_twelve + m.time_am_pm


@mod.capture(rule="<user.prose_time_hours_minutes> | <user.prose_time_hours_am_pm>")
def prose_time(m) -> str:
    return str(m)


@mod.capture(rule="({user.vocabulary} | <user.abbreviation> | <word>)")
def word(m) -> str:
    """A single word, including user-defined vocabulary."""
    if hasattr(m, "vocabulary"):
        return m.vocabulary
    elif hasattr(m, "abbreviation"):
        return m.abbreviation
    else:
        return " ".join(
            actions.dictate.replace_words(actions.dictate.parse_words(m.word))
        )


@mod.capture(rule="({user.vocabulary} | <user.prose_contact> | <phrase>)+")
def text(m) -> str:
    """A sequence of words, including user-defined vocabulary."""
    return format_phrase(m)


@mod.capture(
    rule=(
        "("
        "{user.vocabulary}"
        "| {user.punctuation}"
        "| {user.prose_snippets}"
        "| <user.prose_currency>"
        "| <user.prose_time>"
        "| <user.number_prose_prefixed>"
        "| <user.prose_percent>"
        "| <user.prose_modifier>"
        "| <user.abbreviation>"
        "| <user.prose_contact>"
        "| <phrase>"
        ")+"
    )
)
def prose(m) -> str:
    """Mixed words and punctuation, auto-spaced & capitalized."""
    # Straighten curly quotes that were introduced to obtain proper spacing.
    return apply_formatting(m).replace("", '"').replace("", '"')


@mod.capture(
    rule=(
        "("
        "{user.vocabulary}"
        "| {user.punctuation}"
        "| {user.prose_snippets}"
        "| <user.prose_currency>"
        "| <user.prose_time>"
        "| <user.number_prose_prefixed>"
        "| <user.prose_percent>"
        "| <user.abbreviation>"
        "| <user.prose_contact>"
        "| <phrase>"
        ")+"
    )
)
def raw_prose(m) -> str:
    """Mixed words and punctuation, auto-spaced & capitalized, without quote straightening and commands (for use in dictation mode)."""
    return apply_formatting(m)


# For dragon, omit support for abbreviations and contacts
@ctx_dragon.capture("user.text", rule="({user.vocabulary} | <phrase>)+")
def text_dragon(m) -> str:
    """A sequence of words, including user-defined vocabulary."""
    return format_phrase(m)


@ctx_dragon.capture(
    "user.prose",
    rule="(<phrase> | {user.vocabulary} | {user.punctuation} | {user.prose_snippets} | <user.prose_currency> | <user.prose_time> | <user.prose_number> | <user.prose_percent> | <user.prose_modifier>)+",
)
def prose_dragon(m) -> str:
    """Mixed words and punctuation, auto-spaced & capitalized."""
    # Straighten curly quotes that were introduced to obtain proper spacing.
    return apply_formatting(m).replace("", '"').replace("", '"')


@ctx_dragon.capture(
    "user.raw_prose",
    rule="(<phrase> | {user.vocabulary} | {user.punctuation} | {user.prose_snippets} | <user.prose_currency> | <user.prose_time> | <user.prose_number> | <user.prose_percent>)+",
)
def raw_prose_dragon(m) -> str:
    """Mixed words and punctuation, auto-spaced & capitalized, without quote straightening and commands (for use in dictation mode)."""
    return apply_formatting(m)


# ---------- FORMATTING ---------- #
def format_phrase(m):
    words = capture_to_words(m)
    result = ""
    for i, word in enumerate(words):
        if i > 0 and needs_space_between(words[i - 1], word):
            result += " "
        result += word
    return result


def capture_to_words(m):
    words = []
    for item in m:
        words.extend(
            actions.dictate.replace_words(actions.dictate.parse_words(item))
            if isinstance(item, grammar.vm.Phrase)
            else [item]
        )
    return words


def apply_formatting(m):
    formatter = DictationFormat()
    formatter.state = None
    result = ""
    for item in m:
        # prose modifiers (cap/no cap/no space) produce formatter callbacks.
        if isinstance(item, Callable):
            item(formatter)
        else:
            words = (
                actions.dictate.replace_words(actions.dictate.parse_words(item))
                if isinstance(item, grammar.vm.Phrase)
                else [item]
            )
            for word in words:
                result += formatter.format(word)
    return result


# There must be a simpler way to do this, but I don't see it right now.
no_space_after = re.compile(
    r"""
  (?:
    [\s\-_/#@([{]     # characters that never need space after them
  | (?<!\w)[$]    # currency symbols not preceded by a word character
  # quotes preceded by beginning of string, space, opening braces, dash, or other quotes
  | (?: ^ | [\s([{\-'"] ) ['"]
  )$""",
    re.VERBOSE,
)
no_space_before = re.compile(
    r"""
  ^(?:
    [\s\-_.,!?/%)\]}]   # characters that never need space before them
  | [$](?!\w)        # currency symbols not followed by a word character
  | [;:](?!-\)|-\()        # colon or semicolon except for smiley faces
  # quotes followed by end of string, space, closing braces, dash, other quotes, or some punctuation.
  | ['"] (?: $ | [\s)\]}\-'".,!?;:/] )
  # apostrophe s
  | 's(?!\w)
  )""",
    re.VERBOSE,
)


def omit_space_before(text: str) -> bool:
    return not text or no_space_before.search(text)


def omit_space_after(text: str) -> bool:
    return not text or no_space_after.search(text)


def needs_space_between(before: str, after: str) -> bool:
    return not (omit_space_after(before) or omit_space_before(after))


# # TESTS, uncomment to enable
# assert needs_space_between("a", "break")
# assert needs_space_between("break", "a")
# assert needs_space_between(".", "a")
# assert needs_space_between("said", "'hello")
# assert needs_space_between("hello'", "said")
# assert needs_space_between("hello.", "'John")
# assert needs_space_between("John.'", "They")
# assert needs_space_between("paid", "$50")
# assert needs_space_between("50$", "payment")
# assert not needs_space_between("", "")
# assert not needs_space_between("a", "")
# assert not needs_space_between("a", " ")
# assert not needs_space_between("", "a")
# assert not needs_space_between(" ", "a")
# assert not needs_space_between("a", ",")
# assert not needs_space_between("'", "a")
# assert not needs_space_between("a", "'")
# assert not needs_space_between("and-", "or")
# assert not needs_space_between("mary", "-kate")
# assert not needs_space_between("$", "50")
# assert not needs_space_between("US", "$")
# assert not needs_space_between("(", ")")
# assert not needs_space_between("(", "e.g.")
# assert not needs_space_between("example", ")")
# assert not needs_space_between("example", '".')
# assert not needs_space_between("example", '."')
# assert not needs_space_between("hello'", ".")
# assert not needs_space_between("hello.", "'")

no_cap_after = re.compile(
    r"""(
    e\.g\.
    | i\.e\.
    )$""",
    re.VERBOSE,
)


def auto_capitalize(text, state=None):
    """
    Auto-capitalizes text. Text must contain complete words, abbreviations, and
    formatted expressions. `state` argument means:

    - None: Don't capitalize initial word.
    - "sentence start": Capitalize initial word.
    - "after newline": Don't capitalize initial word, but we're after a newline.
      Used for double-newline detection.

    Returns (capitalized text, updated state).
    """
    output = ""
    # Imagine a metaphorical "capitalization charge" travelling through the
    # string left-to-right.
    charge = state == "sentence start"
    newline = state == "after newline"
    sentence_end = False
    for c in text:
        # Sentence endings followed by space & double newlines create a charge.
        if (sentence_end and c in " \n\t") or (newline and c == "\n"):
            charge = True
        # Alphanumeric characters and commas/colons absorb charge & try to
        # capitalize (for numbers & punctuation this does nothing, which is what
        # we want).
        elif charge and (c.isalnum() or c in ",:"):
            charge = False
            c = c.capitalize()
        # Otherwise the charge just passes through.
        output += c
        newline = c == "\n"
        sentence_end = c in ".!?" and not no_cap_after.search(output)
    return output, (
        "sentence start"
        if charge or sentence_end
        else "after newline" if newline else None
    )


# ---------- DICTATION AUTO FORMATTING ---------- #
class DictationFormat:
    def __init__(self):
        self.reset()

    def reset(self):
        self.reset_context()
        self.force_no_space = False
        self.force_capitalization = None  # Can also be "cap" or "no cap".

    def reset_context(self):
        self.before = ""
        self.state = "sentence start"

    def update_context(self, before):
        if before is None:
            return
        self.reset_context()
        self.pass_through(before)

    def pass_through(self, text):
        _, self.state = auto_capitalize(text, self.state)
        self.before = text or self.before

    def format(self, text, auto_cap=True):
        if not self.force_no_space and needs_space_between(self.before, text):
            text = " " + text
        self.force_no_space = False
        if auto_cap:
            text, self.state = auto_capitalize(text, self.state)
        if self.force_capitalization == "cap":
            text = format_first_letter(text, lambda s: s.capitalize())
            self.force_capitalization = None
        if self.force_capitalization == "no cap":
            text = format_first_letter(text, lambda s: s.lower())
            self.force_capitalization = None
        self.before = text or self.before
        return text

    # These are used as callbacks by prose modifiers / dictation_mode commands.
    def cap(self):
        self.force_capitalization = "cap"

    def no_cap(self):
        self.force_capitalization = "no cap"

    def no_space(self):
        # This is typically used after repositioning the cursor, so it is helpful to
        # reset capitalization as well.
        #
        # FIXME: this sets state to "sentence start", capitalizing the next
        # word. probably undesirable, since most places are not the start of
        # sentences?
        self.reset_context()
        self.force_no_space = True


def format_first_letter(text, formatter):
    i = -1
    for i, c in enumerate(text):
        if c.isalpha():
            break
    if i >= 0 and i < len(text):
        text = text[:i] + formatter(text[i]) + text[i + 1 :]
    return text


dictation_formatter = DictationFormat()
ui.register("app_deactivate", lambda app: dictation_formatter.reset())
ui.register("win_focus", lambda win: dictation_formatter.reset())


def reformat_last_utterance(formatter):
    text = actions.user.get_last_phrase()
    actions.user.clear_last_phrase()
    text = formatter(text)
    actions.user.add_phrase_to_history(text)
    actions.insert(text)


@mod.action_class
class Actions:
    def dictation_format_reset():
        """Resets the dictation formatter"""
        return dictation_formatter.reset()

    def dictation_format_cap():
        """Sets the dictation formatter to capitalize"""
        dictation_formatter.cap()

    def dictation_format_no_cap():
        """Sets the dictation formatter to not capitalize"""
        dictation_formatter.no_cap()

    def dictation_format_no_space():
        """Sets the dictation formatter to not prepend a space"""
        dictation_formatter.no_space()

    def dictation_reformat_cap():
        """Capitalizes the last utterance"""
        reformat_last_utterance(
            lambda s: format_first_letter(s, lambda c: c.capitalize())
        )

    def dictation_reformat_no_cap():
        """Lowercases the last utterance"""
        reformat_last_utterance(lambda s: format_first_letter(s, lambda c: c.lower()))

    def dictation_reformat_no_space():
        """Removes space before the last utterance"""
        reformat_last_utterance(lambda s: s[1:] if s.startswith(" ") else s)

    def dictation_insert_raw(text: str):
        """Inserts text as-is, without invoking the dictation formatter."""
        actions.user.dictation_insert(text, auto_cap=False)

    def dictation_insert(text: str, auto_cap: bool = True) -> str:
        """Inserts dictated text, formatted appropriately."""
        add_space_after = False
        if settings.get("user.context_sensitive_dictation"):
            # Peek left if we might need leading space or auto-capitalization;
            # peek right if we might need trailing space. NB. We peek right
            # BEFORE insertion to avoid breaking the undo-chain between the
            # inserted text and the trailing space.
            need_left = not omit_space_before(text) or (
                auto_cap and text != auto_capitalize(text, "sentence start")[0]
            )
            need_right = not omit_space_after(text)
            before, after = actions.user.dictation_peek(need_left, need_right)
            dictation_formatter.update_context(before)
            add_space_after = after is not None and needs_space_between(text, after)
        text = dictation_formatter.format(text, auto_cap)
        # Straighten curly quotes that were introduced to obtain proper
        # spacing. The formatter context still has the original curly quotes
        # so that future dictation is properly formatted.
        text = text.replace("", '"').replace("", '"')
        actions.user.add_phrase_to_history(text)
        actions.user.insert_between(text, " " if add_space_after else "")

    def dictation_peek(left: bool, right: bool) -> tuple[Optional[str], Optional[str]]:
        """
        Gets text around the cursor to inform auto-spacing and -capitalization.
        Returns (before, after), where `before` is some text before the cursor,
        and `after` some text after it. Results are not guaranteed; `before`
        and/or `after` may be None, indicating no information. If `before` is
        the empty string, this means there is nothing before the cursor (we are
        at the beginning of the document); likewise for `after`.

        To optimize performance, pass `left = False` if you won't need
        `before`, and `right = False` if you won't need `after`.

        dictation_peek() is intended for use before inserting text, so it may
        delete any currently selected text.
        """
        if not (left or right):
            return None, None
        before, after = None, None
        # Inserting a character ensures we select something even if we're at
        # document start; some editors 'helpfully' copy the current line if we
        # edit.copy() while nothing is selected.
        actions.insert(settings.get("user.context_sensitive_dictation_peek_character"))
        if left:
            # In principle the previous word should suffice, but some applications
            # have a funny concept of what the previous word is (for example, they
            # may only take the "`" at the end of "`foo`"). To be double sure we
            # take two words left. I also tried taking a line up + a word left, but
            # edit.extend_up() = key(shift-up) doesn't work consistently in the
            # Slack webapp (sometimes escapes the text box).
            actions.edit.extend_word_left()
            actions.edit.extend_word_left()
            before = actions.edit.selected_text()[:-1]
            # Unfortunately, in web Slack, if our selection ends at newline,
            # this will go right over the newline. Argh.
            actions.edit.right()
        if not right:
            actions.key("backspace")  # remove the peek character
        else:
            actions.edit.left()  # go left before the peek character
            # We want to select at least two characters to the right, plus the character
            # we inserted, because no_space_before needs two characters in the worst
            # case -- for example, inserting before "' hello" we don't want to add
            # space, while inserted before "'hello" we do.
            #
            # We use 2x extend_word_right() because it's fewer keypresses (lower
            # latency) than 3x extend_right(). Other options all seem to have
            # problems. For instance, extend_line_end() might not select all the way
            # to the next newline if text has been wrapped across multiple lines;
            # extend_line_down() sometimes escapes the current text box (eg. in a
            # browser address bar). 1x extend_word_right() _usually_ works, but on
            # Windows in Firefox it doesn't always select enough characters.
            actions.edit.extend_word_right()
            actions.edit.extend_word_right()
            after = actions.edit.selected_text()[1:]
            actions.edit.left()
            actions.user.delete_right()  # remove peek character
        return before, after

  - `user.time_am_pm`: 
<unknown; may be defined elsewhere>



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\text\text_and_dictation.py

- decorator inner: `rule="<user.prose_time_hours_minutes> | <user.prose_time_hours_am_pm>"`

- name: `<no explicit name>`

- raw rule: `<user.prose_time_hours_minutes> | <user.prose_time_hours_am_pm>`

- referenced lists:

  - `user.prose_time_hours_minutes`: 
<unknown; may be defined elsewhere>

  - `user.prose_time_hours_am_pm`: 
<unknown; may be defined elsewhere>



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\text\text_and_dictation.py

- decorator inner: `rule="({user.vocabulary} | <user.abbreviation> | <word>`

- name: `<no explicit name>`

- raw rule: `None`

- Resolved: none



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\text\text_and_dictation.py

- decorator inner: `rule="({user.vocabulary} | <user.prose_contact> | <phrase>`

- name: `<no explicit name>`

- raw rule: `None`

- Resolved: none



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\text\text_and_dictation.py

- decorator inner: `rule=(
        "("
        "{user.vocabulary}"
        "| {user.punctuation}"
        "| {user.prose_snippets}"
        "| <user.prose_currency>"
        "| <user.prose_time>"
        "| <user.number_prose_prefixed>"
        "| <user.prose_percent>"
        "| <user.prose_modifier>"
        "| <user.abbreviation>"
        "| <user.prose_contact>"
        "| <phrase>"
        "`

- name: `<no explicit name>`

- raw rule: `None`

- Resolved: none



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\text\text_and_dictation.py

- decorator inner: `rule=(
        "("
        "{user.vocabulary}"
        "| {user.punctuation}"
        "| {user.prose_snippets}"
        "| <user.prose_currency>"
        "| <user.prose_time>"
        "| <user.number_prose_prefixed>"
        "| <user.prose_percent>"
        "| <user.abbreviation>"
        "| <user.prose_contact>"
        "| <phrase>"
        "`

- name: `<no explicit name>`

- raw rule: `None`

- Resolved: none



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\windows_and_tabs\window_layout.py

- decorator inner: `rule="all"`

- name: `<no explicit name>`

- raw rule: `all`



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\windows_and_tabs\window_layout.py

- decorator inner: `rule="gap"`

- name: `<no explicit name>`

- raw rule: `gap`



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\windows_and_tabs\window_layout.py

- decorator inner: `rule="<user.running_applications>"`

- name: `<no explicit name>`

- raw rule: `<user.running_applications>`

- referenced lists:

  - `user.running_applications`: 
<unknown; may be defined elsewhere>



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\windows_and_tabs\window_layout.py

- decorator inner: `rule="<user.application_windows>|<user.numbered_windows>|<user.skip_window>"`

- name: `<no explicit name>`

- raw rule: `<user.application_windows>|<user.numbered_windows>|<user.skip_window>`

- referenced lists:

  - `user.application_windows`: 
<unknown; may be defined elsewhere>

  - `user.numbered_windows`: 
<unknown; may be defined elsewhere>

  - `user.skip_window`: 
<unknown; may be defined elsewhere>



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\windows_and_tabs\window_layout.py

- decorator inner: `rule="<user.ordinals_small>+"`

- name: `<no explicit name>`

- raw rule: `<user.ordinals_small>+`

- referenced lists:

  - `user.ordinals_small`: 
<unknown; may be defined elsewhere>



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\windows_and_tabs\window_layout.py

- decorator inner: `rule="<user.layout_item>+ [<user.all_candidate_windows>]"`

- name: `<no explicit name>`

- raw rule: `<user.layout_item>+ [<user.all_candidate_windows>]`

- referenced lists:

  - `user.layout_item`: 
<unknown; may be defined elsewhere>

  - `user.all_candidate_windows`: 
<unknown; may be defined elsewhere>



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\windows_and_tabs\window_layout.py

- decorator inner: `rule="{user.window_split_positions} [<user.target_windows>]"`

- name: `<no explicit name>`

- raw rule: `{user.window_split_positions} [<user.target_windows>]`

- referenced lists:

  - `user.window_split_positions`: 
<unknown; not a literal in code>

  - `user.target_windows`: 
<unknown; may be defined elsewhere>



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\core\windows_and_tabs\window_snap.py

- decorator inner: `rule="{user.window_snap_positions}"`

- name: `<no explicit name>`

- raw rule: `{user.window_snap_positions}`

- referenced lists:

  - `user.window_snap_positions`: 
_snap_positions.keys()


@mod.action_class
class Actions:
    def snap_window(
        position: RelativeScreenPos, window: Optional[Window] = None
    ) -> None:
        """Move a window (defaults to the active window) to a specific position on its current screen, given a `RelativeScreenPos` object."""
        if window is None:
            window = ui.active_window()
        _snap_window_helper(window, position)

    def snap_window_to_position(
        position_name: str, window: Optional[Window] = None
    ) -> None:
        """Move a window (defaults to the active window) to a specifically named position on its current screen, using a key from `_snap_positions`."""
        position: Optional[RelativeScreenPos] = None
        if position_name in _snap_positions:
            position = _snap_positions[position_name]
            actions.user.snap_window(position, window)
        else:
            # Previously this function took a spoken form, but we now have constant identifiers in `_snap_positions`.
            # If the user passed a previous spoken form instead, see if we can convert it to the new identifier.
            new_key = actions.user.formatted_text(position_name, "ALL_CAPS,SNAKE_CASE")
            if new_key in _snap_positions:
                actions.user.deprecate_action(
                    "2024-12-02",
                    f"snap_window_to_position('{position_name}')",
                    f"snap_window_to_position('{new_key}')",
                )
                position = _snap_positions[new_key]
                actions.user.snap_window(position, window)
            else:
                raise KeyError(position_name)

    def move_window_next_screen() -> None:
        """Move the active window to a specific screen."""
        _move_to_screen(ui.active_window(), offset=1)

    def move_window_previous_screen() -> None:
        """Move the active window to the previous screen."""
        _move_to_screen(ui.active_window(), offset=-1)

    def move_window_to_screen(screen_number: int) -> None:
        """Move the active window leftward by one."""
        _move_to_screen(ui.active_window(), screen_number=screen_number)

    def snap_app(app_name: str, position: RelativeScreenPos):
        """Snap a specific application to another screen."""
        window = _get_app_window(app_name)
        _bring_forward(window)
        _snap_window_helper(window, position)

    def move_app_to_screen(app_name: str, screen_number: int):
        """Move a specific application to another screen."""
        window = _get_app_window(app_name)
        _bring_forward(window)
        _move_to_screen(
            window,
            screen_number=screen_number,
        )



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\apps\git\git.py

- decorator inner: `rule="{user.git_argument}+"`

- name: `<no explicit name>`

- raw rule: `{user.git_argument}+`

- referenced lists:

  - `user.git_argument`: 
<unknown; not a literal in code>



## Capture in C:\Users\MPhil\AppData\Roaming\talon\user\community\apps\windbg\windbg.py

- decorator inner: `rule="{self.windows_dlls}"`

- name: `<no explicit name>`

- raw rule: `{self.windows_dlls}`

- referenced lists:

  - `self.windows_dlls`: 
<unknown; not a literal in code>



## Extracted symbol spoken forms

- `L Angle` -> `<`

- `L paren` -> `(`

- `R angle` -> `>`

- `R brace` -> `}`

- `R brack` -> `]`

- `R bracket` -> `]`

- `R curly bracket` -> `}`

- `R square` -> `]`

- `amper` -> `&`

- `ampersand` -> `&`

- `and sign` -> `&`

- `angle` -> `<`

- `apostrophe` -> `'`

- `asterisk` -> `*`

- `at sign` -> `@`

- `at symbol` -> `@`

- `back tick` -> ```

- `backslash` -> `\`

- `bang` -> `!`

- `caret` -> `^`

- `colon` -> `:`

- `coma` -> `,`

- `comma` -> `,`

- `dash` -> `-`

- `dollar` -> `$`

- `dollar sign` -> `$`

- `dot` -> `.`

- `double quote` -> `"`

- `down score` -> `_`

- `dub quote` -> `"`

- `equals` -> `=`

- `exclamation mark` -> `!`

- `exclamation point` -> `!`

- `forward slash` -> `/`

- `full stop` -> `.`

- `grave` -> ```

- `greater than` -> `>`

- `hash` -> `#`

- `hash sign` -> `#`

- `hyphen` -> `-`

- `left angle` -> `<`

- `left paren` -> `(`

- `less than` -> `<`

- `minus` -> `-`

- `number sign` -> `#`

- `paren` -> `(`

- `percent` -> `%`

- `percent sign` -> `%`

- `period` -> `.`

- `pipe` -> `|`

- `plus` -> `+`

- `point` -> `.`

- `pound` -> ``

- `pound sign` -> ``

- `question` -> `?`

- `question mark` -> `?`

- `quote` -> `'`

- `rangle` -> `>`

- `right angle` -> `>`

- `right brace` -> `}`

- `right bracket` -> `]`

- `right curly bracket` -> `}`

- `right square` -> `]`

- `semicolon` -> `;`

- `slash` -> `/`

- `star` -> `*`

- `tilde` -> `~`

- `underscore` -> `_`


